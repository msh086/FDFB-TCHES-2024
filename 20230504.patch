diff --git a/src/binfhe/include/binfhe-base-params.h b/src/binfhe/include/binfhe-base-params.h
index c12c5d3..ba37746 100644
--- a/src/binfhe/include/binfhe-base-params.h
+++ b/src/binfhe/include/binfhe-base-params.h
@@ -70,8 +70,9 @@ public:
    * @param method bootstrapping method (DM or CGGI)
    */
     BinFHECryptoParams(const std::shared_ptr<LWECryptoParams> lweparams,
-                       const std::shared_ptr<RingGSWCryptoParams> rgswparams)
-        : m_LWEParams(lweparams), m_RGSWParams(rgswparams) {}
+                       const std::shared_ptr<RingGSWCryptoParams> rgswparams,
+                       bool multithread=false)
+        : m_LWEParams(lweparams), m_RGSWParams(rgswparams), m_multithread(multithread) {}
 
     const std::shared_ptr<LWECryptoParams> GetLWEParams() const {
         return m_LWEParams;
@@ -81,6 +82,10 @@ public:
         return m_RGSWParams;
     }
 
+    bool GetMultithread() const {
+        return m_multithread;
+    }
+
     bool operator==(const BinFHECryptoParams& other) const {
         return *m_LWEParams == *other.m_LWEParams && *m_RGSWParams == *other.m_RGSWParams;
     }
@@ -119,6 +124,9 @@ private:
 
     // shared pointer to an instance of RGSWCryptoParams
     std::shared_ptr<RingGSWCryptoParams> m_RGSWParams = nullptr;
+
+    // whether multithreading is enabled
+    bool m_multithread;
 };
 
 }  // namespace lbcrypto
diff --git a/src/binfhe/include/binfhe-base-scheme.h b/src/binfhe/include/binfhe-base-scheme.h
index 43e46aa..85c33b7 100644
--- a/src/binfhe/include/binfhe-base-scheme.h
+++ b/src/binfhe/include/binfhe-base-scheme.h
@@ -53,6 +53,22 @@ typedef struct {
     RingGSWACCKey BSkey;
     // switching key
     LWESwitchingKey KSkey;
+    // packing key with nOnes = N
+    RLWESwitchingKey PKkey_full;
+    // packing key with nOnes = N/2
+    RLWESwitchingKey PKkey_half;
+    // packing key with nOnes = N/8. NOTE: not needed for now
+    // RLWESwitchingKey PKkey_batch;
+    // packing key with one constant term set to 1
+    RLWESwitchingKey PKkey_const;
+    // packing key from sk to skN with nOnes = N/2. used for ReLU
+    RLWESwitchingKey PKKey_half_trans;
+    // BFV relinearization key
+    std::shared_ptr<std::vector<RLWECiphertext>> BFV_relin_keys;
+    // FIXME: remove; debug key
+    LWEPrivateKey skey;
+    LWEPrivateKey skeyN;
+    NativePoly skeyNTT;
 } RingGSWBTKey;
 
 /**
@@ -83,7 +99,8 @@ public:
    * LWE scheme
    * @return a shared pointer to the refreshing key
    */
-    RingGSWBTKey KeyGen(const std::shared_ptr<BinFHECryptoParams> params, ConstLWEPrivateKey LWEsk) const;
+    RingGSWBTKey KeyGen(const std::shared_ptr<BinFHECryptoParams> params, ConstLWEPrivateKey LWEsk,
+                        ConstLWEPrivateKey skN, RingGSWBTKey* ref) const;
 
     /**
    * Evaluates a binary gate (calls bootstrapping as a subroutine)
@@ -136,6 +153,226 @@ public:
                            ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
                            const NativeInteger beta) const;
 
+    /**
+   * Evaluate an arbitrary function (using new LUT format, i.e. Zp-Zp mapping for upscaled messages, real-real mapping for CKKS messages)
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncTest(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                               ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, const NativeInteger beta,
+                               double deltain, double deltaout, NativeInteger qout, double (*f)(double m)) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-Compress
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @param is_signed if we interpret input as signed or not
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncCompress(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                   ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                   const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                   double (*f)(double m), bool is_signed = true) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-CancelSign
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncCancelSign(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                     ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                     const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                     double (*f)(double m)) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-Select
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @param EK_small small EK for non-multi-value bts
+   * @param baseG_small small Bg for non-multi-value bts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncSelect(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                 ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, const NativeInteger beta,
+                                 double deltain, double deltaout, NativeInteger qout, double (*f)(double m),
+                                 const RingGSWBTKey& EK_small, uint32_t baseG_small) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-SelectAlt(3 bts)
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @param EK_small small EK for non-multi-value bts
+   * @param baseG_small small Bg for non-multi-value bts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncSelectAlt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                    ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                    const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                    double (*f)(double m), const RingGSWBTKey& EK_small, uint32_t baseG_small) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-PreSelect
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @param p_mid intermediate plaintext modulus for digit decomposition, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncPreSelect(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                    ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                    const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                    double (*f)(double m), NativeInteger p_mid) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB [KS21]  // only for benchmarking purpose
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @param p_mid intermediate plaintext modulus for digit decomposition, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncKS21(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                               ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, const NativeInteger beta,
+                               double deltain, double deltaout, NativeInteger qout, double (*f)(double m)) const;
+    /**
+     * Evaluate an arbitrary function using Comp [CZB+22]
+     * 
+    * @param params a shared pointer to RingGSW scheme parameters
+    * @param EK a shared pointer to the bootstrapping keys
+    * @param ct input ciphertext
+    * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+    * @param beta the error bound
+    * @param deltain scaling factor of input CKKS ciphertext
+    * @param deltaout scaling factor of output CKKS ciphertext
+    * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+    * @param EK_small small EK for non-multi-value bts
+    * @param baseG_small small Bg for non-multi-value bts
+    * @param multi_thread whether use multithreading to accelerate
+    * @return a shared pointer to the resulting ciphertext
+    */
+    LWECiphertext EvalFuncComp(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                               ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, const NativeInteger beta,
+                               double deltain, double deltaout, NativeInteger qout, double (*f)(double m),
+                               uint32_t f_property, double shift, const RingGSWBTKey& EK_small,
+                               uint32_t baseG_small) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-BFVMult(improved WoPPBS-2)
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param qout output modulus, used only for CKKS ciphertexts
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncBFV(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                              ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, const NativeInteger beta,
+                              double deltain, double deltaout, NativeInteger qout, double (*f)(double m)) const;
+
+    /**
+   * Evaluate an arbitrary function using original WoPPBS-2
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param qout output modulus, used only for CKKS ciphertexts
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncWoPPBS2(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                  ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                  const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                  double (*f)(double m)) const;
+
+    /**
+   * Evaluate an arbitrary function using WoPPBS-1
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct input ciphertext
+   * @param LUT the look-up table of the to-be-evaluated function, used only for Zp ciphertexts
+   * @param beta the error bound
+   * @param deltain scaling factor of input CKKS ciphertext
+   * @param deltaout scaling factor of output CKKS ciphertext
+   * @param qout output modulus, used only for CKKS ciphertexts
+   * @param f real function to be evaluated on CKKS ciphertext, used only for CKKS ciphertexts
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncWoPPBS1(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                  ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                  const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                  double (*f)(double m)) const;
+
+    /**
+     * Evalute ReLU function
+     * 
+     * @param params a shared pointer to RingGSW scheme parameters
+     * @param EK a shared pointer to the bootstrapping keys
+     * @param ct input ciphertext
+     * @param beta error bound for ct_sgn
+    */
+    LWECiphertext EvalReLU(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK_sgn,
+                           uint32_t baseG_sgn, const RingGSWBTKey& EK_sel, uint32_t baseG_sel, ConstLWECiphertext ct,
+                           ConstLWECiphertext ct_msd, size_t beta) const;
+
     /**
    * Evaluate a round down function
    *
@@ -178,7 +415,142 @@ public:
    */
     std::vector<LWECiphertext> EvalDecomp(const std::shared_ptr<BinFHECryptoParams> params,
                                           const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
-                                          const NativeInteger beta) const;
+                                          const NativeInteger beta, bool CKKS) const;
+    /**
+   * Evaluate a round down function for an extracted CKKS ciphertext or a Brakerski's ciphertext with large error
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorAlt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                               ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precision for an extracted CKKS ciphertext or a Brakerski's ciphertext with large error
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @param fast follow HomFloorAlt by HomFloor for better performance
+   * @param CKKS whether ct is an extracted CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignAlt(const std::shared_ptr<BinFHECryptoParams> params,
+                              const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                              const NativeInteger beta, bool fast, bool CKKS) const;
+
+    /**
+   * Evaluate a degit decomposition process for an extracted CKKS ciphertext or a Brakerski's ciphertext with large error
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @param fast follow HomFloorAlt by HomFloor for better performance
+   * @param CKKS whether ct is an extracted CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    std::vector<LWECiphertext> EvalDecompAlt(const std::shared_ptr<BinFHECryptoParams> params,
+                                             const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                             const NativeInteger beta, bool CKKS) const;
+    /**
+   * Perform homomorphic LSB reduction
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorNew(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                               ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precision using HomReduce
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignNew(const std::shared_ptr<BinFHECryptoParams> params,
+                              const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                              const NativeInteger beta) const;
+
+    /**
+   * Evaluate a degit decomposition process over a large precision LWE ciphertext using HomReduce
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    std::vector<LWECiphertext> EvalDecompNew(const std::shared_ptr<BinFHECryptoParams> params,
+                                             const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                             const NativeInteger beta, bool CKKS) const;
+    /**
+   * Clear LSBs using EvalFuncCompress
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorCompress(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                    ConstLWECiphertext ct, const NativeInteger beta, const NativeInteger precise_beta,
+                                    uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precision using EvalFloorCompress
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignCompress(const std::shared_ptr<BinFHECryptoParams> params,
+                                   const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                   const NativeInteger beta, const NativeInteger precise_beta) const;
+
+    /**
+   * Evaluate a degit decomposition process over a large precision LWE ciphertext using HomReduce
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param &EK a shared pointer to the bootstrapping keys
+   * @param ct1 input ciphertext
+   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param beta the error bound
+   * @param bigger_q the ciphertext modulus
+   * @return a shared pointer to the resulting ciphertext
+   */
+    std::vector<LWECiphertext> EvalDecompCompress(const std::shared_ptr<BinFHECryptoParams> params,
+                                                  const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                                  const NativeInteger beta, const NativeInteger precise_beta,
+                                                  bool CKKS) const;
 
 private:
     /**
@@ -212,18 +584,219 @@ private:
 
     /**
    * Bootstraps a fresh ciphertext
+   * NOTE: we add param `modswitch so that we can still use BootstrapFunc for multi-value bootstrap
    *
    * @param params a shared pointer to RingGSW scheme parameters
    * @param &EK a shared pointer to the bootstrapping keys
-   * @param gate the gate; can be AND, OR, NAND, NOR, XOR, or XOR
-   * @param &a first part of the input LWE ciphertext
-   * @param &b second part of the input LWE ciphertext
-   * @param lwescheme a shared pointer to additive LWE scheme
+   * @param ct input LWE ciphertext
+   * @param f function that maps from ct.modulus to fmod (in multi-value boostrap, this will be a packed function. but the packed representation is transparent to BootstrapFunc)
+   * @param fmod output ciphertext modulus (and output modulus for f)
+   * @param modswitch if set to true, the ctxt after KS will be mod switched to fmod and returned; otherwise it is directly returned
+   * @param raw if set to true, the ctxt after blind rotation will be directly returned, without MS or KS
    * @return the output RingLWE accumulator
    */
     template <typename Func>
     LWECiphertext BootstrapFunc(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
-                                ConstLWECiphertext ct, const Func f, const NativeInteger fmod) const;
+                                ConstLWECiphertext ct, const Func f, const NativeInteger fmod, bool raw = false,
+                                bool ms = true) const;
+
+    /**
+   * Core bootstrapping operation
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct LWE ciphertext encrypting the index
+   * @param tv RLWE ciphertext, the test vector
+   * @return a shared pointer to the resulting ciphertext
+   */
+    RLWECiphertext BootstrapCtxtCore(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWACCKey ek,
+                                     ConstLWECiphertext ct, ConstRLWECiphertext tv) const;
+
+    /**
+   * Bootstrap an RLWE ciphertext
+   *
+   * @param params a shared pointer to RingGSW scheme parameters
+   * @param EK a shared pointer to the bootstrapping keys
+   * @param ct LWE ciphertext encrypting the index
+   * @param tv RLWE ciphertext, the test vector
+   * @param fmod output modulus
+   * @param raw if set to true, the acc after blind rotation will be directly returned without MS or KS
+   * @return the output RingLWE accumulator
+   */
+    LWECiphertext BootstrapCtxt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                ConstLWECiphertext ct, ConstRLWECiphertext tv, const NativeInteger fmod,
+                                bool raw = false, bool ms = true) const;
+
+    /**
+   * Changes a polynomial in R_Q to a scaled one in R_q
+   *
+   * @param q modulus to switch to
+   * @param polyQ the input polynomial
+   * @return resulting polynomial
+   */
+    NativeVector ModSwitch(NativeInteger q, const NativeVector& polyQ) const;
+
+    /**
+   * Changes a polynomial in R_Q to a scaled one in R_q inplace
+   *
+   * @param q modulus to switch to
+   * @param polyQ the input polynomial
+   */
+    void ModSwitchInplace(NativeInteger q, NativeVector& polyQ) const;
+
+    /**
+     * Change RLWE ciphertext from vector representation to polynomial representation
+    */
+    RLWECiphertext vecs_to_RLWECiphertext(std::vector<NativeVector>&& vectors,
+                                          const std::shared_ptr<ILNativeParams> params) const;
+
+    /**
+   * Generates a switching key to go from an LWE secret key with (q,N) to an RLWE secret
+   * key with (Q,N), at the same time evaluating linear map a |-> a*(1+X+X^2+...+X^(N/2-1)).
+   * i.e. produce a test vector (in ciphertext)
+   *
+   * @param params parameter for BinFHEScheme
+   * @param sk old LWE secret key
+   * @param skN new RLWE secret key in vector form
+   * @param nOnes number of ones in linear map basis, i.e. 1+X+...+X^(nOnes-1)
+   * @return a shared pointer to the switching key
+   */
+    RLWESwitchingKey FunctionalKeySwitchGen(const std::shared_ptr<BinFHECryptoParams> params, ConstLWEPrivateKey sk,
+                                            const NativePoly& skNTT, usint nOnes) const;
+
+    /**
+   * Switches ciphertext from LWE(q,N) to RLWE(Q,N), at the same time evaluating linear map
+   * {[m_i], pos_i} |-> sum(m_i*(1+X+...+X^(nOnes-1))*X^pos_i). pos_i is the param of RLWESwitchingKey
+   * i.e. produce a test vector (in ciphertext)
+   *
+   * @param params parameter for BinFHEScheme
+   * @param K switching key
+   * @param nOnes number of ones in linear map basis, i.e. 1+X+...+X^(nOnes-1)
+   * @param messages vector of {LWE ciphertext, right shift pos} pairs
+   * @return a shared pointer to the resulting ciphertext
+   */
+    RLWECiphertext FunctionalKeySwitch(const std::shared_ptr<BinFHECryptoParams> params, ConstRLWESwitchingKey K,
+                                       usint nOnes,
+                                       const std::vector<std::pair<ConstLWECiphertext, size_t>>& messages) const;
+
+    //XXX: debug
+    RLWECiphertext FunctionalKeySwitchSimple(const std::shared_ptr<BinFHECryptoParams> params, ConstRLWESwitchingKey K,
+                                             usint nOnes,
+                                             const std::vector<std::pair<ConstLWECiphertext, size_t>>& messages) const;
+
+    // NTL::ZZ_pX ToZZpX(const NativeVector& vec) const;
+
+    // NativeVector FromZZpX(const NTL::ZZ_pX& poly) const;
+
+    NativeVector PolyMult(const NativeVector& a, const NativeVector& s) const;
+
+    /**
+     * Extracts LWE ciphertexts packed in a large modulus Q
+     * XXX: as a proof of concept version, we only support power-of-2 plaintext space for packed messages
+     *      we note that non-power-of-2 plaintext space can also be supported by using an intermediate modulus
+     * XXX: not used or implemented
+     * 
+     * @param ct input LWE ciphertext with large modulus
+     * @param msg_info vector of pairs, where each pair = <bit of message, bit of output modulus>
+     * @param padding number of padding bits between messages (usually set to 1)
+    */
+    // std::vector<LWECiphertext> ExtractMultipleMessages(ConstLWECiphertext ct,
+    //                                                    const std::vector<std::pair<size_t, size_t>>& msg_info,
+    //                                                    size_t padding = 1) const;
+
+    /**
+     * Evaluate the negation of an LWE ciphertext
+    */
+    LWECiphertext EvalNegate(ConstLWECiphertext ct) const;
+
+    /**
+     * Extract LWE ciphertext from RLWE ciphertext
+     * @param acc input RLWE ciphertext
+     * NOTE: this function modifies ct
+    */
+    LWECiphertext ExtractACC(RLWECiphertext acc) const;
+
+    /**
+     * Extract the LWE ciphertext corresponding to X^pos from RLWE ciphertext
+    */
+    LWECiphertext ManualExtract(ConstRLWECiphertext acc, size_t pos) const;
+
+    /**
+     * generate the RLWE' ciphertext for multi-value bootstrap or low noise multiplication (encrypting X^m*TV_0*B^i)
+     * 
+     * @param params BinFHE scheme parameter
+     * @param ct input LWE ciphertext as the LUT index (we require that ct is already 'unsigned')
+     * @param beta bound of e_bt
+     * @param p plaintext modulus
+     * @param FDFB when set to true, generate RLWE' ciphertext for FDFB multi-value bootstrap (encrypting sgn(m)*X^m*TV_0*B^i and X^m*TV_0*B^i)
+    */
+    std::vector<RLWECiphertext> PrepareRLWEPrime(const std::shared_ptr<BinFHECryptoParams> params,
+                                                 const RingGSWBTKey& EK, ConstLWECiphertext ct, NativeInteger beta,
+                                                 size_t p, bool FDFB) const;
+
+    /**
+     * perform batch selection.
+     * first ct will be bootstrapped to create an encryption of narrow-ranged [sgn], then this ciphertext is used to blind rotate a test vector
+     * 
+     * @param params BinFHE scheme parameter
+     * @param ct input LWE ciphertext as the selector (we require that ct is already 'unsigned')
+     * @param beta bound of e_bt
+     * @param pn_values vector of (pos_val, neg_val) pairs modulo Q, indicating the values to be selected when ct encrypts positive / negative message
+     * 
+     * @return vector of selected LWE ciphertexts under (Q,N)
+    */
+    std::vector<LWECiphertext> BatchSelect(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                           ConstLWECiphertext ct, NativeInteger beta,
+                                           const std::vector<std::pair<NativeInteger, NativeInteger>>& pn_values) const;
+
+    /**
+     * sign-decompose a polynomial using base B
+     * 
+     * @param poly input polynomial to decompose
+     * @param q the inner modulus for poly (i.e. we will mult poly by Q/q*..., so both q and Q can be viewed as poly's modulus)
+     * @param B base for decomposition
+    */
+    std::vector<NativePoly> SignedDecomp(const std::shared_ptr<BinFHECryptoParams> params, const NativePoly& poly,
+                                         size_t q, size_t B) const;
+
+    /**
+     * inner product between RLWE' and decomposed polynomial
+     * 
+     * @param rlwe_prime RLWE' ciphertext
+     * @param decomposed decomposed polynomial
+    */
+    RLWECiphertext InnerProduct(const std::vector<RLWECiphertext>& rlwe_prime,
+                                const std::vector<NativePoly>& decomposed) const;
+
+    /**
+     * BFV multiplication between two RLWE ciphertexts
+     * 
+     * @param params BinFHE scheme parameter
+     * @param EK RGSWBTKey
+     * @param ct1 RLWE(Q/p*m1)
+     * @param ct2 RLWE(Q/p*m2)
+     * @param p plaintext modulus
+     * @return RLWE(Q/p*m1m2)
+    */
+    RLWECiphertext BFVMult(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                           const RLWECiphertext& ct1, const RLWECiphertext& ct2, uint32_t p) const;
+
+    /**
+     * Generate BFV relinearization keys
+     * 
+     * @param params BinFHE scheme parameters
+     * @param skNTT RLWE secret key in NTT form
+     * @return an RLWE' ciphertext encrypting skNTT
+    */
+    std::shared_ptr<std::vector<RLWECiphertext>> GenBFVRelinKeys(const std::shared_ptr<BinFHECryptoParams> params,
+                                                                 const NativePoly& skNTT) const;
+
+    NativeVector ComputeTV1(const NativeVector& tv) const;
+
+    void inspect_lwe_ctxt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK, uint32_t p,
+                          ConstLWECiphertext ct, std::string name) const;
+
+    int64_t inspect_lwe_ptxt(LWEPlaintext ptxt, uint32_t p, NativeInteger mod) const;
 
 protected:
     std::shared_ptr<LWEEncryptionScheme> LWEscheme = std::make_shared<LWEEncryptionScheme>();
diff --git a/src/binfhe/include/binfhecontext.h b/src/binfhe/include/binfhecontext.h
index af72d9f..cc9f35e 100644
--- a/src/binfhe/include/binfhecontext.h
+++ b/src/binfhe/include/binfhecontext.h
@@ -81,6 +81,29 @@ public:
    * Should be used with care (only for advanced users familiar with LWE
    * parameter selection).
    *
+   * @param n lattice parameter for additive LWE scheme
+   * @param N ring dimension for RingGSW/RLWE used in bootstrapping
+   * @param &q modulus for additive LWE
+   * @param &Q modulus for RingGSW/RLWE used in bootstrapping
+   * @param std standard deviation
+   * @param baseKS the base used for key switching
+   * @param baseG the gadget base used in bootstrapping
+   * @param baseR the base used for refreshing
+   * @param method the bootstrapping method (DM or CGGI)
+   * @return creates the cryptocontext
+   */
+    void GenerateBinFHEContext(uint32_t n, uint32_t N, const NativeInteger& q, const NativeInteger& Q,
+                               const NativeInteger& qKS, double std, uint32_t baseKS, uint32_t baseG, uint32_t baseR,
+                               uint32_t basePK, const NativeInteger& qfrom, uint32_t baseG0, uint32_t baseGMV,
+                               uint32_t beta_precise, uint32_t p, const std::vector<uint32_t>& baseGs,
+                               uint32_t pkkey_flags, bool multithread, const NativeInteger& P, uint32_t baseRL,
+                               BINFHE_METHOD method = GINX);
+
+    /**
+   * Creates a crypto context using custom parameters.
+   * Should be used with care (only for advanced users familiar with LWE
+   * parameter selection).
+   *
    * @param sl the parameter set: TOY, MEDIUM, STD128, STD192, STD256
    * @param arbFunc whether need to evaluate an arbitrary function using functional bootstrapping
    * @param logQ log(input ciphertext modulus)
@@ -90,7 +113,7 @@ public:
    * @return creates the cryptocontext
    */
     void GenerateBinFHEContext(BINFHE_PARAMSET set, bool arbFunc, uint32_t logQ = 11, int64_t N = 0,
-                               BINFHE_METHOD method = GINX, bool timeOptimization = false);
+                               BINFHE_METHOD method = GINX, bool timeOptimization = false, uint32_t B_g = 0);
 
     /**
    * Creates a crypto context using predefined parameters sets. Recommended for
@@ -240,6 +263,162 @@ public:
    */
     LWECiphertext EvalFunc(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT) const;
 
+    /**
+   * Evaluate an arbitrary function (using new format of LUT)
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncTest(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                               double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-Compress
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncCompress(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                   double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-CancelSign
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncCancelSign(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                     double deltaout = 0, NativeInteger qout = 0,
+                                     double (*f)(double m) = nullptr) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-Select
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @param use_multi_value_bts when set to true, use multi-value BTS to decrease running time
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncSelect(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                 double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr,
+                                 uint32_t baseG_small = 1 << 27) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-SelectAlt
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @param use_multi_value_bts when set to true, use multi-value BTS to decrease running time
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncSelectAlt(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                    double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr,
+                                    uint32_t baseG_small = 1 << 27) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB-PreSelect
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncPreSelect(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                    double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr,
+                                    NativeInteger p_mid = 0) const;
+
+    /**
+   * Evaluate an arbitrary function using FDFB [KS21]
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncKS21(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                               double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+   * Evaluate an arbitrary function using Comp[CZB+22]
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param LUT the look-up table of the to-be-evaluated function
+   * @param deltain input scaling factor of CKKS ciphertext
+   * @param deltaout output scaling factor of CKKS ciphertext
+   * @param f real function to be evaluated on CKKS ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFuncComp(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                               double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr,
+                               uint32_t f_property = 0, double shift = 0, uint32_t baseG_small = 1 << 27) const;
+
+    /**
+     * Evaluate an arbitrary function using FDFB-BFVMult
+     * 
+    * @param ct1 ciphertext to be bootstrapped
+    * @param LUT the look-up table of the to-be-evaluated function
+    * @param deltain input scaling factor of CKKS ciphertext
+    * @param deltaout output scaling factor of CKKS ciphertext
+    * @param f real function to be evaluated on CKKS ciphertext
+    */
+    LWECiphertext EvalFuncBFV(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                              double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+     * Evaluate an arbitrary function using updated WoPPBS-1 (a padding bit)
+     * 
+    * @param ct1 ciphertext to be bootstrapped
+    * @param LUT the look-up table of the to-be-evaluated function
+    * @param deltain input scaling factor of CKKS ciphertext
+    * @param deltaout output scaling factor of CKKS ciphertext
+    * @param f real function to be evaluated on CKKS ciphertext
+    */
+    LWECiphertext EvalFuncWoPPBS1(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                  double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+     * Evaluate an arbitrary function using updated WoPPBS-2 (no padding bit)
+     * 
+    * @param ct1 ciphertext to be bootstrapped
+    * @param LUT the look-up table of the to-be-evaluated function
+    * @param deltain input scaling factor of CKKS ciphertext
+    * @param deltaout output scaling factor of CKKS ciphertext
+    * @param f real function to be evaluated on CKKS ciphertext
+    */
+    LWECiphertext EvalFuncWoPPBS2(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain = 0,
+                                  double deltaout = 0, NativeInteger qout = 0, double (*f)(double m) = nullptr) const;
+
+    /**
+     * Evaluate ReLU function
+     * 
+     * @param ct input ciphertext
+     * @param ct_msd ciphertext storing most significant digit of ct
+     * @param beta error bound. beta = 0 means ct is in CKKS-style
+    */
+    LWECiphertext EvalReLU(ConstLWECiphertext ct, ConstLWECiphertext ct_msd, size_t baseG_sgn, size_t baseG_sel) const;
+
     /**
    * Generate the LUT for the to-be-evaluated function
    *
@@ -273,7 +452,82 @@ public:
    * @param ct1 ciphertext to be bootstrapped
    * @return a vector of shared pointers to the resulting ciphertexts
    */
-    std::vector<LWECiphertext> EvalDecomp(ConstLWECiphertext ct);
+    std::vector<LWECiphertext> EvalDecomp(ConstLWECiphertext ct, bool CKKS = false);
+
+    /**
+   * Evaluate a round down function
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param roundbits number of bits to be rounded
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorAlt(ConstLWECiphertext ct, uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precisions
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignAlt(ConstLWECiphertext ct, bool fast, bool CKKS);
+
+    /**
+   * Evaluate ciphertext decomposition
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a vector of shared pointers to the resulting ciphertexts
+   */
+    std::vector<LWECiphertext> EvalDecompAlt(ConstLWECiphertext ct, bool CKKS = false);
+
+    /**
+   * Evaluate a round down function
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param roundbits number of bits to be rounded
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorNew(ConstLWECiphertext ct, uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precisions
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignNew(ConstLWECiphertext ct);
+
+    /**
+   * Evaluate ciphertext decomposition
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a vector of shared pointers to the resulting ciphertexts
+   */
+    std::vector<LWECiphertext> EvalDecompNew(ConstLWECiphertext ct, bool CKKS = false);
+
+    /**
+   * Evaluate a round down function
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @param roundbits number of bits to be rounded
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalFloorCompress(ConstLWECiphertext ct, uint32_t roundbits = 0) const;
+
+    /**
+   * Evaluate a sign function over large precisions
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext EvalSignCompress(ConstLWECiphertext ct);
+
+    /**
+   * Evaluate ciphertext decomposition
+   *
+   * @param ct1 ciphertext to be bootstrapped
+   * @return a vector of shared pointers to the resulting ciphertexts
+   */
+    std::vector<LWECiphertext> EvalDecompCompress(ConstLWECiphertext ct, bool CKKS = false);
 
     /**
    * Evaluates NOT gate
@@ -331,7 +585,12 @@ public:
     }
 
     NativeInteger GetBeta() const {
-        return 128;
+        return m_half_gap;
+    }
+
+    // precise beta (bootstrapping error is close to rescaling error)
+    NativeInteger GetBetaPrecise() const {
+        return m_beta_precise;
     }
 
 private:
@@ -352,6 +611,11 @@ private:
 
     // Whether to optimize time for sign eval
     bool m_timeOptimization = false;
+
+    // precise beta
+    uint32_t m_beta_precise = 55;  // for standard params, beta_precise = 55
+    // half gap
+    uint32_t m_half_gap = 0;
 };
 
 }  // namespace lbcrypto
diff --git a/src/binfhe/include/lwe-keyswitchkey-fwd.h b/src/binfhe/include/lwe-keyswitchkey-fwd.h
index f38192e..0e312a7 100644
--- a/src/binfhe/include/lwe-keyswitchkey-fwd.h
+++ b/src/binfhe/include/lwe-keyswitchkey-fwd.h
@@ -35,9 +35,15 @@
 
 namespace lbcrypto {
 class LWESwitchingKeyImpl;
+class LWESwitchingKeyMultImpl;
+class RLWESwitchingKeyImpl;
 
 using LWESwitchingKey      = std::shared_ptr<LWESwitchingKeyImpl>;
 using ConstLWESwitchingKey = const std::shared_ptr<const LWESwitchingKeyImpl>;
+using LWESwitchingKeyMult      = std::shared_ptr<LWESwitchingKeyMultImpl>;
+using ConstLWESwitchingKeyMult = const std::shared_ptr<const LWESwitchingKeyMultImpl>;
+using RLWESwitchingKey = std::shared_ptr<RLWESwitchingKeyImpl>;
+using ConstRLWESwitchingKey = const std::shared_ptr<const RLWESwitchingKeyImpl>;
 }  // namespace lbcrypto
 
 #endif  // __LWE_KEYSWITCHKEY_FWD_H__
diff --git a/src/binfhe/include/lwe-keyswitchkey.h b/src/binfhe/include/lwe-keyswitchkey.h
index c0fab18..78e24b7 100644
--- a/src/binfhe/include/lwe-keyswitchkey.h
+++ b/src/binfhe/include/lwe-keyswitchkey.h
@@ -129,6 +129,178 @@ private:
     std::vector<std::vector<std::vector<NativeInteger>>> m_keyB;
 };
 
+/**
+ * @brief Class that stores the LWE scheme switching key (mult-style)
+ */
+class LWESwitchingKeyMultImpl : public Serializable {
+public:
+    LWESwitchingKeyMultImpl() = default;
+
+    explicit LWESwitchingKeyMultImpl(const std::vector<std::vector<NativeVector>>& keyA,
+                                 const std::vector<std::vector<NativeInteger>>& keyB)
+        : m_keyA(keyA), m_keyB(keyB) {}
+
+    explicit LWESwitchingKeyMultImpl(const LWESwitchingKeyMultImpl& rhs) {
+        m_keyA = rhs.m_keyA;
+        m_keyB = rhs.m_keyB;
+    }
+
+    explicit LWESwitchingKeyMultImpl(const LWESwitchingKeyMultImpl&& rhs) {
+        m_keyA = std::move(rhs.m_keyA);
+        m_keyB = std::move(rhs.m_keyB);
+    }
+
+    const LWESwitchingKeyMultImpl& operator=(const LWESwitchingKeyMultImpl& rhs) {
+        m_keyA = rhs.m_keyA;
+        m_keyB = rhs.m_keyB;
+        return *this;
+    }
+
+    const LWESwitchingKeyMultImpl& operator=(const LWESwitchingKeyMultImpl&& rhs) {
+        m_keyA = std::move(rhs.m_keyA);
+        m_keyB = std::move(rhs.m_keyB);
+        return *this;
+    }
+
+    const std::vector<std::vector<NativeVector>>& GetElementsA() const {
+        return m_keyA;
+    }
+
+    const std::vector<std::vector<NativeInteger>>& GetElementsB() const {
+        return m_keyB;
+    }
+
+    void SetElementsA(const std::vector<std::vector<NativeVector>>& keyA) {
+        m_keyA = keyA;
+    }
+
+    void SetElementsB(const std::vector<std::vector<NativeInteger>>& keyB) {
+        m_keyB = keyB;
+    }
+
+    bool operator==(const LWESwitchingKeyMultImpl& other) const {
+        return (m_keyA == other.m_keyA && m_keyB == other.m_keyB);
+    }
+
+    bool operator!=(const LWESwitchingKeyMultImpl& other) const {
+        return !(*this == other);
+    }
+
+    template <class Archive>
+    void save(Archive& ar, std::uint32_t const version) const {
+        ar(::cereal::make_nvp("a", m_keyA));
+        ar(::cereal::make_nvp("b", m_keyB));
+    }
+
+    template <class Archive>
+    void load(Archive& ar, std::uint32_t const version) {
+        if (version > SerializedVersion()) {
+            OPENFHE_THROW(deserialize_error, "serialized object version " + std::to_string(version) +
+                                                 " is from a later version of the library");
+        }
+
+        ar(::cereal::make_nvp("a", m_keyA));
+        ar(::cereal::make_nvp("b", m_keyB));
+    }
+
+    std::string SerializedObjectName() const {
+        return "LWEPrivateKeyMult";
+    }
+    static uint32_t SerializedVersion() {
+        return 1;
+    }
+
+private:
+    std::vector<std::vector<NativeVector>> m_keyA;
+    std::vector<std::vector<NativeInteger>> m_keyB;
+};
+
+/**
+ * @brief Class that stores the RLWE scheme switching key
+ */
+class RLWESwitchingKeyImpl : public Serializable {
+public:
+    RLWESwitchingKeyImpl() = default;
+
+    explicit RLWESwitchingKeyImpl(const std::vector<std::vector<std::vector<NativeVector>>>& keyA,
+                                  const std::vector<std::vector<std::vector<NativeVector>>>& keyB)
+        : m_keyA(keyA), m_keyB(keyB) {}
+
+    explicit RLWESwitchingKeyImpl(const RLWESwitchingKeyImpl& rhs) {
+        m_keyA = rhs.m_keyA;
+        m_keyB = rhs.m_keyB;
+    }
+
+    explicit RLWESwitchingKeyImpl(const RLWESwitchingKeyImpl&& rhs) {
+        m_keyA = std::move(rhs.m_keyA);
+        m_keyB = std::move(rhs.m_keyB);
+    }
+
+    const RLWESwitchingKeyImpl& operator=(const RLWESwitchingKeyImpl& rhs) {
+        m_keyA = rhs.m_keyA;
+        m_keyB = rhs.m_keyB;
+        return *this;
+    }
+
+    const RLWESwitchingKeyImpl& operator=(const RLWESwitchingKeyImpl&& rhs) {
+        m_keyA = std::move(rhs.m_keyA);
+        m_keyB = std::move(rhs.m_keyB);
+        return *this;
+    }
+
+    const std::vector<std::vector<std::vector<NativeVector>>>& GetElementsA() const {
+        return m_keyA;
+    }
+
+    const std::vector<std::vector<std::vector<NativeVector>>>& GetElementsB() const {
+        return m_keyB;
+    }
+
+    void SetElementsA(const std::vector<std::vector<std::vector<NativeVector>>>& keyA) {
+        m_keyA = keyA;
+    }
+
+    void SetElementsB(const std::vector<std::vector<std::vector<NativeVector>>>& keyB) {
+        m_keyB = keyB;
+    }
+
+    bool operator==(const RLWESwitchingKeyImpl& other) const {
+        return (m_keyA == other.m_keyA && m_keyB == other.m_keyB);
+    }
+
+    bool operator!=(const RLWESwitchingKeyImpl& other) const {
+        return !(*this == other);
+    }
+
+    template <class Archive>
+    void save(Archive& ar, std::uint32_t const version) const {
+        ar(::cereal::make_nvp("a", m_keyA));
+        ar(::cereal::make_nvp("b", m_keyB));
+    }
+
+    template <class Archive>
+    void load(Archive& ar, std::uint32_t const version) {
+        if (version > SerializedVersion()) {
+            OPENFHE_THROW(deserialize_error, "serialized object version " + std::to_string(version) +
+                                                 " is from a later version of the library");
+        }
+
+        ar(::cereal::make_nvp("a", m_keyA));
+        ar(::cereal::make_nvp("b", m_keyB));
+    }
+
+    std::string SerializedObjectName() const {
+        return "RLWESwitchingKey";
+    }
+    static uint32_t SerializedVersion() {
+        return 1;
+    }
+
+private:
+    std::vector<std::vector<std::vector<NativeVector>>> m_keyA;
+    std::vector<std::vector<std::vector<NativeVector>>> m_keyB;
+};
+
 }  // namespace lbcrypto
 
 #endif
diff --git a/src/binfhe/include/lwe-pke.h b/src/binfhe/include/lwe-pke.h
index 55269fb..dea3d77 100644
--- a/src/binfhe/include/lwe-pke.h
+++ b/src/binfhe/include/lwe-pke.h
@@ -126,6 +126,29 @@ public:
    */
     LWECiphertext KeySwitch(const std::shared_ptr<LWECryptoParams> params, ConstLWESwitchingKey K,
                             ConstLWECiphertext ctQN) const;
+   
+    /**
+   * Generates a (mult-style) switching key to go from a secret key with (Q,N) to a secret
+   * key with (q,n)
+   *
+   * @param params a shared pointer to LWE scheme parameters
+   * @param sk new secret key
+   * @param skN old secret key
+   * @return a shared pointer to the switching key
+   */
+    LWESwitchingKeyMult KeySwitchGenMult(const std::shared_ptr<LWECryptoParams> params, ConstLWEPrivateKey sk,
+                                 ConstLWEPrivateKey skN) const;
+
+    /**
+   * Switches ciphertext from (Q,N) to (Q,n) using mult-stype switching key
+   *
+   * @param params a shared pointer to LWE scheme parameters
+   * @param K switching key
+   * @param ctQN input ciphertext
+   * @return a shared pointer to the resulting ciphertext
+   */
+    LWECiphertext KeySwitchMult(const std::shared_ptr<LWECryptoParams> params, ConstLWESwitchingKeyMult K,
+                            ConstLWECiphertext ctQN) const;
 
     /**
    * Embeds a plaintext bit without noise or encryption
diff --git a/src/binfhe/include/rgsw-cryptoparameters.h b/src/binfhe/include/rgsw-cryptoparameters.h
index 0d8f68f..57e674e 100644
--- a/src/binfhe/include/rgsw-cryptoparameters.h
+++ b/src/binfhe/include/rgsw-cryptoparameters.h
@@ -60,6 +60,10 @@ class RingGSWCryptoParams : public Serializable {
 public:
     RingGSWCryptoParams() = default;
 
+    constexpr static uint32_t PKKEY_FULL       = 1 << 0;
+    constexpr static uint32_t PKKEY_HALF       = 1 << 1;
+    constexpr static uint32_t PKKEY_CONST      = 1 << 2;
+    constexpr static uint32_t PKKEY_HALF_TRANS = 1 << 3;
     /**
    * Main constructor for RingGSWCryptoParams
    *
@@ -69,8 +73,23 @@ public:
    * @param method bootstrapping method (DM or CGGI)
    */
     explicit RingGSWCryptoParams(uint32_t N, NativeInteger Q, NativeInteger q, uint32_t baseG, uint32_t baseR,
-                                 BINFHE_METHOD method, double std, bool signEval = false)
-        : m_N(N), m_Q(Q), m_q(q), m_baseG(baseG), m_baseR(baseR), m_method(method) {
+                                 BINFHE_METHOD method, double std, bool signEval = false, uint32_t basePK = 1 << 5,
+                                 const NativeInteger& qfrom = uint64_t(1) << 35, uint32_t baseG0 = 1 << 6,
+                                 uint32_t baseGMV = 1 << 6, const std::vector<uint32_t>& baseGs = {},
+                                 uint32_t pkkey_flags = 0, NativeInteger P = 0, uint32_t baseRL = 0)
+        : m_N(N),
+          m_Q(Q),
+          m_q(q),
+          m_baseG(baseG),
+          m_baseR(baseR),
+          m_method(method),
+          m_basePK(basePK),
+          m_qfrom(qfrom),
+          m_baseG0(baseG0),
+          m_baseGMV(baseGMV),
+          m_pkkey_flags(pkkey_flags),
+          m_P(P),
+          m_baseRL(baseRL) {
         if (!IsPowerOfTwo(baseG)) {
             OPENFHE_THROW(config_error, "Gadget base should be a power of two.");
         }
@@ -84,6 +103,13 @@ public:
 
         // Precomputes a polynomial for MSB extraction
         m_polyParams = std::make_shared<ILNativeParams>(2 * N, Q, rootOfUnity);
+
+        if(m_P > 0){
+            NativeInteger rootOfUnity_P = RootOfUnity<NativeInteger>(2 * N, m_P);
+            ChineseRemainderTransformFTT<NativeVector>().PreCompute(rootOfUnity_P, 2 * N, m_P);
+            m_polyParams_bfv = std::make_shared<ILNativeParams>(2 * N, m_P, rootOfUnity_P);
+        }
+
         m_digitsG    = (uint32_t)std::ceil(log(Q.ConvertToDouble()) / log(static_cast<double>(m_baseG)));
         if (m_method == AP) {
             uint32_t digitCountR =
@@ -121,6 +147,21 @@ public:
             }
         }
 
+        if (baseGs.size() > 0) {
+            for (size_t j = 0; j < baseGs.size(); ++j) {
+                NativeInteger vTemp = NativeInteger(1);
+                auto tempdigits = (uint32_t)std::ceil(log(Q.ConvertToDouble()) / log(static_cast<double>(baseGs[j])));
+                std::vector<NativeInteger> tempvec(tempdigits);
+                for (size_t i = 0; i < tempdigits; ++i) {
+                    tempvec[i] = vTemp;
+                    vTemp      = vTemp.ModMul(NativeInteger(baseGs[j]), Q);
+                }
+                m_Gpower_map[baseGs[j]] = tempvec;
+                if (m_baseG == baseGs[j])
+                    m_Gpower = tempvec;
+            }
+        }
+
         // Sets the gate constants for supported binary operations
         m_gateConst = {
             NativeInteger(5) * (q >> 3),  // OR
@@ -167,6 +208,10 @@ public:
         return m_Q;
     }
 
+    const NativeInteger& GetP() const {
+        return m_P;
+    }
+
     const NativeInteger& Getq() const {
         return m_q;
     }
@@ -183,6 +228,30 @@ public:
         return m_baseR;
     }
 
+    uint32_t GetBasePK() const {
+        return m_basePK;
+    }
+
+    const NativeInteger& GetQfrom() const {
+        return m_qfrom;
+    }
+
+    uint32_t GetBaseG0() const {
+        return m_baseG0;
+    }
+
+    uint32_t GetBaseGMV() const {
+        return m_baseGMV;
+    }
+
+    uint32_t GetBaseRL() const {
+        return m_baseRL;
+    }
+
+    uint32_t GetPKKeyFlags() const {
+        return m_pkkey_flags;
+    }
+
     const std::vector<NativeInteger>& GetDigitsR() const {
         return m_digitsR;
     }
@@ -191,6 +260,10 @@ public:
         return m_polyParams;
     }
 
+    const std::shared_ptr<ILNativeParams> GetPolyParamsP() const {
+        return m_polyParams_bfv;
+    }
+
     const std::vector<NativeInteger>& GetGPower() const {
         return m_Gpower;
     }
@@ -216,7 +289,9 @@ public:
     }
 
     bool operator==(const RingGSWCryptoParams& other) const {
-        return m_N == other.m_N && m_Q == other.m_Q && m_baseR == other.m_baseR && m_baseG == other.m_baseG;
+        return m_N == other.m_N && m_Q == other.m_Q && m_baseR == other.m_baseR && m_baseG == other.m_baseG &&
+               m_basePK == other.m_basePK && m_qfrom == other.m_qfrom && m_baseG0 == other.m_baseG0 &&
+               m_baseGMV == other.m_baseGMV && m_pkkey_flags == other.m_pkkey_flags && m_P == other.m_P && m_baseRL == other.m_baseRL;
     }
 
     bool operator!=(const RingGSWCryptoParams& other) const {
@@ -234,6 +309,11 @@ public:
         ar(::cereal::make_nvp("bs", m_dgg.GetStd()));
         ar(::cereal::make_nvp("bdigitsG", m_digitsG));
         ar(::cereal::make_nvp("bparams", m_polyParams));
+        ar(::cereal::make_nvp("bPK", m_basePK));
+        ar(::cereal::make_nvp("qfrom", m_qfrom));
+        ar(::cereal::make_nvp("bG0", m_baseG0));
+        ar(::cereal::make_nvp("bGMV", m_baseGMV));
+        ar(::cereal::make_nvp("bflag", m_pkkey_flags));
     }
 
     template <class Archive>
@@ -253,6 +333,11 @@ public:
         m_dgg.SetStd(sigma);
         ar(::cereal::make_nvp("bdigitsG", m_digitsG));
         ar(::cereal::make_nvp("bparams", m_polyParams));
+        ar(::cereal::make_nvp("bPK", m_basePK));
+        ar(::cereal::make_nvp("qfrom", m_qfrom));
+        ar(::cereal::make_nvp("bG0", m_baseG0));
+        ar(::cereal::make_nvp("bGMV", m_baseGMV));
+        ar(::cereal::make_nvp("bflag", m_pkkey_flags));
 
         PreCompute();
     }
@@ -315,6 +400,31 @@ private:
 
     // Bootstrapping method (DM or CGGI)
     BINFHE_METHOD m_method = BINFHE_METHOD::INVALID_METHOD;
+
+    // Base used in LWE to RLWE packing
+    uint32_t m_basePK;
+
+    // input modulus for LWE to RLWE packing, output modulus is always Q
+    NativeInteger m_qfrom;
+
+    // Base used in polynomial x RLWE' multiplication in FDFB-PreSelect
+    uint32_t m_baseG0;
+
+    // Base used in low-noise multi-value bootstrap
+    uint32_t m_baseGMV;
+
+    // flags indicating which packing keys should be generated
+    uint32_t m_pkkey_flags;
+
+    //##################### BFV part
+    // modulus for auxiliary modulus in BFV mult
+    NativeInteger m_P = 0;
+
+    // parameters for polymonials modulo P
+    std::shared_ptr<ILNativeParams> m_polyParams_bfv;
+
+    // base used in BFV relinearization
+    uint32_t m_baseRL;
 };
 
 }  // namespace lbcrypto
diff --git a/src/binfhe/lib/binfhe-base-scheme.cpp b/src/binfhe/lib/binfhe-base-scheme.cpp
index 5cd4e2f..54f6611 100644
--- a/src/binfhe/lib/binfhe-base-scheme.cpp
+++ b/src/binfhe/lib/binfhe-base-scheme.cpp
@@ -32,25 +32,64 @@
 #include "binfhe-base-scheme.h"
 
 #include <string>
+#include <utility>
+#include <omp.h>
 
 namespace lbcrypto {
 
 // wrapper for KeyGen methods
-RingGSWBTKey BinFHEScheme::KeyGen(const std::shared_ptr<BinFHECryptoParams> params, ConstLWEPrivateKey LWEsk) const {
-    auto& LWEParams        = params->GetLWEParams();
-    ConstLWEPrivateKey skN = LWEscheme->KeyGen(LWEParams->GetN(), LWEParams->GetQ());
+RingGSWBTKey BinFHEScheme::KeyGen(const std::shared_ptr<BinFHECryptoParams> params, ConstLWEPrivateKey LWEsk,
+                                  ConstLWEPrivateKey skN, RingGSWBTKey* ref) const {
+    auto& LWEParams = params->GetLWEParams();
+    auto N          = LWEParams->GetN();
+    // ConstLWEPrivateKey skN = LWEscheme->KeyGen(LWEParams->GetN(), LWEParams->GetQ());
 
+    // FIXME: refractor: there is no need to store KSkey & PKkey in every RingGSWBTKey, because it is not affected by baseG...
+    //  maybe store the map from baseG to ACCkey in a single RingGSWBTKey? instead of storing multiple RingGSWBTKeys...
     RingGSWBTKey ek;
-    ek.KSkey = LWEscheme->KeySwitchGen(LWEParams, LWEsk, skN);
 
     auto& RGSWParams   = params->GetRingGSWParams();
     auto polyParams    = RGSWParams->GetPolyParams();
     NativePoly skNPoly = NativePoly(polyParams);
-    skNPoly.SetValues(skN->GetElement(), Format::COEFFICIENT);
-    skNPoly.SetFormat(Format::EVALUATION);
 
+    if (ref != nullptr) {
+        ek.PKkey_full       = ref->PKkey_full;
+        ek.PKkey_half       = ref->PKkey_half;
+        ek.PKkey_const      = ref->PKkey_const;
+        ek.KSkey            = ref->KSkey;
+        ek.PKKey_half_trans = ref->PKKey_half_trans;
+        ek.BFV_relin_keys   = ref->BFV_relin_keys;
+
+        ek.skeyNTT = ref->skeyNTT;
+        skNPoly    = ek.skeyNTT;
+    }
+    else {
+        skNPoly.SetValues(skN->GetElement(), Format::COEFFICIENT);
+        skNPoly.SetFormat(Format::EVALUATION);
+        ek.skeyNTT = skNPoly;
+
+        ek.KSkey = LWEscheme->KeySwitchGen(LWEParams, LWEsk, skN);
+        if (params->GetRingGSWParams()->GetBasePK() != 0) {
+            auto flags = params->GetRingGSWParams()->GetPKKeyFlags();
+            if (flags & RingGSWCryptoParams::PKKEY_FULL)
+                ek.PKkey_full = this->FunctionalKeySwitchGen(params, skN, skNPoly, N);
+            if (flags & RingGSWCryptoParams::PKKEY_HALF)
+                ek.PKkey_half = this->FunctionalKeySwitchGen(params, skN, skNPoly, N / 2);
+            if (flags & RingGSWCryptoParams::PKKEY_CONST)
+                ek.PKkey_const = this->FunctionalKeySwitchGen(params, skN, skNPoly, 1);
+            if (flags & RingGSWCryptoParams::PKKEY_HALF_TRANS)
+                ek.PKKey_half_trans = this->FunctionalKeySwitchGen(params, LWEsk, skNPoly, N / 2);
+        }
+        if (params->GetRingGSWParams()->GetP() != 0) {
+            ek.BFV_relin_keys = this->GenBFVRelinKeys(params, skNPoly);
+        }
+    }
     ek.BSkey = ACCscheme->KeyGenAcc(RGSWParams, skNPoly, LWEsk);
 
+    // DEBUG only
+    ek.skey  = std::make_shared<LWEPrivateKeyImpl>(*LWEsk);
+    ek.skeyN = std::make_shared<LWEPrivateKeyImpl>(*skN);
+
     return ek;
 }
 
@@ -243,6 +282,8 @@ LWECiphertext BinFHEScheme::EvalFunc(const std::shared_ptr<BinFHECryptoParams> p
         ct4->SetModulus(q);
         return ct4;
     }
+    std::cout << "WARNING: periodic function for sign-canceling like FDFB\n";
+    // NOTE: this case is a little unnatural... to evaluate this we need q=2N, but for arbitrary function evaluation, q is always N
     // Else it's periodic function so we evaluate directly
     LWEscheme->EvalAddConstEq(ct1, beta);
     // this is 1/4q_small or -1/4q_small mod q
@@ -268,189 +309,2633 @@ LWECiphertext BinFHEScheme::EvalFunc(const std::shared_ptr<BinFHECryptoParams> p
     return BootstrapFunc(params, EK, ct2, fLUT1, q);
 }
 
-// Evaluate Homomorphic Flooring
-LWECiphertext BinFHEScheme::EvalFloor(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
-                                      ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits) const {
-    auto& LWEParams   = params->GetLWEParams();
-    NativeInteger q   = roundbits == 0 ? LWEParams->Getq() : beta * 2 * (1 << roundbits);
-    NativeInteger mod = ct->GetModulus();
+LWECiphertext BinFHEScheme::EvalFuncTest(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                         ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                         const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                         double (*f)(double m)) const {
+    auto& LWEParams = params->GetLWEParams();
+    auto Q          = LWEParams->GetQ();
 
     auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
-    LWEscheme->EvalAddConstEq(ct1, beta);
+    // Get what time of function it is
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        LWEscheme->EvalAddConstEq(ct1, q / 2);  // move (-q/2,q/2) to (0,q)
+        auto dq = q << 1;
+        ct1->SetModulus(dq);
+        auto fLUTsgn = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)         // here q = 2 * actual q
+                return Q - q / 4;  // -actual q / 2
+            else
+                return q / 4;
+        };
+        auto ct2 = BootstrapFunc(params, EK, ct1, fLUTsgn, dq);
+        LWEscheme->EvalAddConstEq(ct2, q / 2);
+        LWEscheme->EvalSubEq(ct1, ct2);
+        // now ct1 is in [0,q] in Z_2q (approximately)
+        // NOTE: overflow may occur if input message is too close to \pm q/2
+        auto fLUThalf = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                     NativeInteger Q) -> NativeInteger {
+            if (x < q / 2) {  // here q = 2 * actual q
+                int64_t xin = x.ConvertToInt();
+                xin -= int64_t((q / 4).ConvertToInt());  // - actual q / 2
+                int64_t fval = std::round(f(xin / deltain) * deltaout * Q.ConvertToDouble() / qout.ConvertToDouble());
+                fval %= int64_t(Q.ConvertToInt());
+                if (fval < 0)
+                    fval += int64_t(Q.ConvertToInt());
+                return fval;
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTfull = [fLUThalf](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUThalf(x, q, Q);
+            else
+                return (Q - fLUThalf(x - q / 2, q, Q)).Mod(Q);
+        };
+        auto ct_res = BootstrapFunc(params, EK, ct1, fLUTfull, Q, false, false);
+        return LWEscheme->ModSwitch(qout, ct_res);
+        // TODO: test
+    }
 
-    auto ct1Modq = std::make_shared<LWECiphertextImpl>(*ct1);
-    ct1Modq->SetModulus(q);
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+    uint32_t N = LWEParams->GetN();
+    if (q > N) {  // need q to be at most = N for arbitary function
+        std::string errMsg =
+            "ERROR: ciphertext modulus q needs to be <= ring dimension for arbitrary function evaluation";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    NativeInteger dq = q << 1;
+    // raise the modulus of ct1 : q -> 2q
+    ct1->GetA().SetModulus(dq);
+    auto ct2 = std::make_shared<LWECiphertextImpl>(*ct1);
+    LWEscheme->EvalAddConstEq(ct2, half_gap);
     // this is 1/4q_small or -1/4q_small mod q
-    auto f1 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    auto f0 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
         if (x < q / 2)
             return Q - q / 4;
         else
             return q / 4;
     };
-    auto ct2 = BootstrapFunc(params, EK, ct1Modq, f1, mod);
-    LWEscheme->EvalSubEq(ct1, ct2);
-
-    auto ct2Modq = std::make_shared<LWECiphertextImpl>(*ct1);
-    ct2Modq->SetModulus(q);
+    auto ct3 = BootstrapFunc(params, EK, ct2, f0, dq);
+    LWEscheme->EvalSubEq2(ct1, ct3);
+    LWEscheme->EvalAddConstEq(ct3, half_gap);
+    LWEscheme->EvalSubConstEq(ct3, q >> 1);
 
-    // now the input is only within the range [0, q/2)
-    auto f2 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
-        if (x < q / 4)
-            return Q - q / 2 - x;
-        else if ((q / 4 <= x) && (x < 3 * q / 4))
-            return x;
+    // Now the input is within the range [0, q/2).
+    // Note that for non-periodic function, the input q is boosted up to 2q
+    auto fLUT = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return (LUT[(x * 2 * p / q).ConvertToInt()] * Q / 2 + p / 2) / p;  // input q/2->p, output p->Q/2
         else
-            return Q + q / 2 - x;
+            return (Q - (LUT[((x - q / 2) * 2 * p / q).ConvertToInt()] * Q / 2 + p / 2) / p).Mod(Q);
     };
-    auto ct3 = BootstrapFunc(params, EK, ct2Modq, f2, mod);
-    LWEscheme->EvalSubEq(ct1, ct3);
-
-    return ct1;
+    auto ct4 = BootstrapFunc(params, EK, ct3, fLUT, dq);
+    ct4->SetModulus(q);
+    return ct4;
 }
 
-// Evaluate large-precision sign
-LWECiphertext BinFHEScheme::EvalSign(const std::shared_ptr<BinFHECryptoParams> params,
-                                     const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
-                                     const NativeInteger beta) const {
-    auto mod         = ct->GetModulus();
-    auto& LWEParams  = params->GetLWEParams();
-    auto& RGSWParams = params->GetRingGSWParams();
-
-    NativeInteger q = LWEParams->Getq();
+// for EvalFunc, size of LUT = modulus of ct
+// but here, for EvalFuncCompress, EvalFuncCancelSign, EvalFuncSelect, we treat LUT as a p-sized array representing a Z_p to Z_p mapping (if f is nullptr)
+// when f is not nullptr, we ignore LUT and compute CKKS function
+LWECiphertext BinFHEScheme::EvalFuncCompress(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                             ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                             const NativeInteger beta, double deltain, double deltaout,
+                                             NativeInteger qout, double (*f)(double m), bool is_signed) const {
+    // always full range
+    // auto& LWEParams = params->GetLWEParams();
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
 
-    if (mod <= q) {
-        std::string errMsg =
-            "ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly";
-        OPENFHE_THROW(not_implemented_error, errMsg);
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        NativeInteger Q = params->GetLWEParams()->GetQ();
+        if (qout == 0)
+            qout = q;  // when output modulus is not given, use the same as input modulus
+        // compression: map 0 to beta, q/2-1 to q/4 - beta
+        // f(x) = slope * x + beta for 0<=x<q/2, f(x) = q - slope * (x-q/2) - beta for q/2<=x<q
+        double slope = (q / 4 - 2 * beta).ConvertToDouble() / (q / 2 - 1).ConvertToDouble();
+        auto fLUTc   = [beta, slope](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return static_cast<uint64_t>(slope * x.ConvertToDouble() + beta.ConvertToDouble());
+            else
+                return (Q - static_cast<uint64_t>(slope * (x - q / 2).ConvertToDouble() + beta.ConvertToDouble()))
+                    .Mod(Q);
+        };
+        auto ct_c = BootstrapFunc(params, EK, ct1, fLUTc, q);
+        // evaluate LUT
+        auto fLUThalf = [f, beta, slope, deltain, deltaout, qout, is_signed](NativeInteger x, NativeInteger q,
+                                                                             NativeInteger Q) -> NativeInteger {
+            if (x < q / 4) {
+                double xin;
+                if (x <= beta)
+                    xin = 0;
+                else if (x >= q / 4 - beta)
+                    xin = q.ConvertToDouble() / 2 - 1;
+                else
+                    xin = (x - beta).ConvertToDouble() / slope;
+                auto tmp = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout * Q.ConvertToDouble() / qout.ConvertToDouble()));
+                tmp %= Q.ConvertToInt();
+                if (tmp < 0)
+                    tmp += Q.ConvertToInt();
+                return static_cast<uint64_t>(tmp);
+            }
+            else if (x >= 3 * q / 4) {
+                // NOTE: (q-x-beta) / slope + q/2 = input x, however, since input x has MSB=1, we need to interpret it as a signed number
+                //  i.e. actual x = input x - q = (q-x-beta)/slope - q/2
+                double xin;
+                if (x <= 3 * q / 4 + beta)
+                    xin = -1;  // q-1
+                else if (x >= q - beta)
+                    xin = -(q.ConvertToDouble()) / 2;  // q/2 - q
+                else
+                    xin = (q - x - beta).ConvertToDouble() / slope - q.ConvertToDouble() / 2;
+                if (!is_signed)
+                    xin += q.ConvertToDouble();
+                auto tmp = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout * Q.ConvertToDouble() / qout.ConvertToDouble()));
+                tmp %= Q.ConvertToInt();
+                if (tmp < 0)
+                    tmp += Q.ConvertToInt();
+                return static_cast<uint64_t>(tmp);
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTfull = [fLUThalf](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 4 || x >= 3 * q / 4)
+                return fLUThalf(x, q, Q);
+            else
+                return (Q - fLUThalf((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        auto ct_ans = BootstrapFunc(params, EK, ct_c, fLUTfull, Q, false, false);  // return unscaled ciphertext
+        return LWEscheme->ModSwitch(qout, ct_ans);
     }
 
-    const auto curBase = RGSWParams->GetBaseG();
-    auto search        = EKs.find(curBase);
-    if (search == EKs.end()) {
-        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
-        OPENFHE_THROW(openfhe_error, errMsg);
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+    // NOTE: we assume that the input function is not negacyclic
+    // NOTE: non power-of-2 p will NOT lead to rounding errors, because the preparation of fLUT is similar to decryption floor(x*p/Q)
+    // uint32_t functionProperty = checkInputFunction(LUT, p);  // NOTE: use p here
+    // if (functionProperty == 0) {                             // negacyclic function only needs one bootstrap
+    //     // TODO: warn on large p
+    //     // generate fLUT of q entries: fLUT[i] = round( LUT_p[ceil(i*p/q)] * Q/p )
+    //     auto fLUT = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //         return ((LUT[(x * p / q).ConvertToInt()] * Q + p / 2) / p).Mod(Q);
+    //     };
+    //     LWEscheme->EvalAddConstEq(ct1, half_gap);  // NOTE: half gap here
+    //     return BootstrapFunc(params, EK, ct1, fLUT, q);
+    // }
+
+    // arbitary funciton
+    // find the amplification factor alpha
+    // the two margins are (alpha/2 - B) and (q/4 - (p-1)alpha/2 - B), if they are equal, alpha = q / (2p)
+    usint alpha = ((q + p) / (2 * p)).ConvertToInt();  // round(q/2p)
+
+    alpha += (alpha & 1);
+    if ((alpha / 2 < beta) || (q / 4 - (p - 1) * alpha / 2 < beta)) {
+        alpha -= 2;
+        if ((alpha / 2 < beta) || (q / 4 - (p - 1) * alpha / 2 < beta))
+            OPENFHE_THROW(openfhe_error, "plaintext modulus p too large, compression cannot be done");
     }
-    RingGSWBTKey curEK(search->second);
 
-    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
-    while (mod > q) {
-        cttmp = EvalFloor(params, curEK, cttmp, beta);
-        mod   = mod / q * 2 * beta;
-        // round Q to 2betaQ/q
-        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+    // computation
+    // make the error positive
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+    // compression
+    auto fc = [alpha, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        usint xp = (x * p / q).ConvertToInt();
+        if (xp < p / 2)
+            return alpha * xp + alpha / 2;
+        else
+            return Q - alpha * (xp - p / 2) - alpha / 2;
+    };
+    auto ct2 = BootstrapFunc(params, EK, ct1, fc, q);  // alpha-amplified message
+
+    // the non-negacyclic LUT, defined on [0,q/4) & [3q/4,q)
+    auto halfLUT = [LUT, alpha, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 4) {
+            if (x >= (p / 2 - 1) * alpha)
+                return (LUT[p / 2 - 1] * Q + p / 2) / p;
+            return (LUT[x.ConvertToInt() / alpha] * Q + p / 2) / p;
+        }
+        else if (x >= 3 * q / 4) {
+            usint minus_part = (q - x).ConvertToInt() - 1;  // again in [0,3q/4)
+            if (minus_part >= (p / 2 - 1) * alpha)
+                return (LUT[p - 1] * Q + p / 2) / p;
+            return (LUT[minus_part / alpha + p / 2] * Q + p / 2) / p;
+        }
+        else
+            OPENFHE_THROW(openfhe_error, "this branch should never be reached");
+    };
+    // no more negacyclicity constraint
+    auto fLUT = [halfLUT](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 4 || x >= 3 * q / 4)
+            return halfLUT(x, q, Q);
+        else
+            return (Q - halfLUT((x + q / 2).Mod(q), q, Q)).Mod(Q);
+    };
 
-        if (EKs.size() == 3) {  // if dynamic
-            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
-            uint32_t base   = 0;
-            if (binLog <= static_cast<uint32_t>(17))
-                base = static_cast<uint32_t>(1) << 27;
-            else if (binLog <= static_cast<uint32_t>(26))
-                base = static_cast<uint32_t>(1) << 18;
+    return BootstrapFunc(params, EK, ct2, fLUT, q);
+}
 
-            if (0 != base) {  // if base is to change ...
-                RGSWParams->Change_BaseG(base);
+LWECiphertext BinFHEScheme::EvalFuncCancelSign(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                               ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                               const NativeInteger beta, double deltain, double deltaout,
+                                               NativeInteger qout, double (*f)(double m)) const {
+    // two versions, one for modraise and cancel, one for periodic (like in EvalFunc)
+    auto LWEParams  = params->GetLWEParams();
+    auto RGSWParams = params->GetRingGSWParams();
+    uint32_t N      = LWEParams->GetN();
 
-                auto search = EKs.find(base);
-                if (search == EKs.end()) {
-                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
-                    OPENFHE_THROW(openfhe_error, errMsg);
-                }
-                curEK = search->second;
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    // Get what time of function it is
+    NativeInteger q = ct->GetModulus();
+
+    if (f != nullptr) {
+        NativeInteger Q = LWEParams->GetQ();
+        if (qout == 0)
+            qout = q;
+        auto dq = q << 1;
+        ct1->SetModulus(dq);
+        auto fLUThalf = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                     NativeInteger Q) -> NativeInteger {
+            int64_t q_u = static_cast<int64_t>(q.ConvertToInt());
+            if (x < q / 2) {
+                int64_t xin = x.ConvertToInt();
+                if (xin >= q_u / 4)
+                    xin -= q_u / 2;
+                int64_t fval = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout / qout.ConvertToDouble() * Q.ConvertToDouble()));
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
             }
-        }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTfull = [fLUThalf](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUThalf(x, q, Q);
+            else
+                return (Q - fLUThalf((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        auto ct2    = BootstrapFunc(params, EK, ct1, fLUTfull, Q, true);  // get raw ciphertext
+        auto ct_sel = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(ct2, N + 1)});
+        return BootstrapCtxt(params, EK, ct1, ct_sel, qout);
+    }
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+    // uint32_t functionProperty = checkInputFunction(LUT, p);  // NOTE: change to p here
+    // if (functionProperty == 0) {                             // negacyclic function only needs one bootstrap
+    //     // TODO: warn on large p
+    //     // generate fLUT of q entries: fLUT[i] = round( LUT_p[ceil(i*p/q)] * Q/p )
+    //     auto fLUT = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //         return ((LUT[(x * p / q).ConvertToInt()] * Q + p / 2) / p).Mod(Q);
+    //     };
+    //     LWEscheme->EvalAddConstEq(ct1, half_gap);  // NOTE: half gap here
+    //     return BootstrapFunc(params, EK, ct1, fLUT, q);
+    // }
+    // arbitary funciton
+    NativeInteger qfrom = RGSWParams->GetQfrom();
+
+    if (q > N) {  // need q to be at most = N for arbitary function
+        std::string errMsg =
+            "ERROR: ciphertext modulus q needs to be <= ring dimension for arbitrary function evaluation";
+        OPENFHE_THROW(not_implemented_error, errMsg);
     }
-    LWEscheme->EvalAddConstEq(cttmp, beta);
 
-    // if the ended q is smaller than q, we need to change the param for the final boostrapping
-    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
-        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    auto fLUT = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return (LUT[(2 * x * p / q).ConvertToInt()] * Q / 2 + p / 2) /
+                   p;  // input decoding(q/2 -> p), output encoding(p -> Q/2)
+        else
+            return (Q - (LUT[(2 * (x - q / 2) * p / q).ConvertToInt()] * Q / 2 + p / 2) / p).Mod(Q);
     };
-    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
-    RGSWParams->Change_BaseG(curBase);
-    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
-    return cttmp;
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+    // raise the modulus of ct1 : q -> 2q
+    NativeInteger dq = q << 1;
+    ct1->GetA().SetModulus(dq);  // B is simply a NativeInteger without a modulus, so only A is handled here
+    // evaluate the function anyway, yielding (-1)^beta*f(m)
+    auto ct2 =
+        LWEscheme->ModSwitch(qfrom, BootstrapFunc(params, EK, ct1, fLUT, dq, true));  // NOTE: return raw ciphertext
+
+    // let ct be the encryption of (-1)^beta*f(m)
+    // we need to set TV = -(-1)^beta*f(m) * (1+X+...+X^(N-1)), which corresponds to +: ct_pos, -: ct_neg
+    auto packed = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(ct2, size_t(N + 1))});
+
+    auto ct3 = BootstrapCtxt(params, EK, ct1, packed, dq);
+    ct3->SetModulus(q);
+    return ct3;
 }
 
-// Evaluate Ciphertext Decomposition
-std::vector<LWECiphertext> BinFHEScheme::EvalDecomp(const std::shared_ptr<BinFHECryptoParams> params,
-                                                    const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
-                                                    const NativeInteger beta) const {
-    auto mod         = ct->GetModulus();
-    auto& LWEParams  = params->GetLWEParams();
-    auto& RGSWParams = params->GetRingGSWParams();
+LWECiphertext BinFHEScheme::EvalFuncSelect(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                           ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                           const NativeInteger beta, double deltain, double deltaout,
+                                           NativeInteger qout, double (*f)(double m), const RingGSWBTKey& EK_small,
+                                           uint32_t baseG_small) const {
+    // always full range
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto Q           = LWEParams->GetQ();
+    auto N           = LWEParams->GetN();
+    auto qKS         = LWEParams->GetqKS();
+    auto baseGMV     = RGSWparams->GetBaseGMV();
+    auto polyparams  = params->GetRingGSWParams()->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1                 = std::make_shared<LWECiphertextImpl>(*ct);
+    bool use_multi_value_bts = baseGMV > 0;
 
-    NativeInteger q = LWEParams->Getq();
-    if (mod <= q) {
-        std::string errMsg =
-            "ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly";
-        OPENFHE_THROW(not_implemented_error, errMsg);
+    NativeInteger q = ct->GetModulus();
+    if (f !=
+        nullptr) {  // NOTE: for CKKS-extracted LWE ciphertext, we do not use multi-value bootstrap to accelerate it, since the error analysis is quite tricky and function dependant
+        if (use_multi_value_bts)
+            OPENFHE_THROW(
+                openfhe_error,
+                "using multi-value bootstrap to accelerate FDFB-Select on CKKS-extracted ciphertexts is not supported");
+        if (qout == 0)
+            qout = q;
+
+        auto fLUTpos = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                    NativeInteger Q) -> NativeInteger {
+            if (x < q / 2) {
+                int64_t xin  = x.ConvertToInt();
+                int64_t fval = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout / qout.ConvertToDouble() * Q.ConvertToDouble()));
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTneg = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                    NativeInteger Q) -> NativeInteger {
+            if (x >= q / 2) {
+                int64_t xin  = x.ConvertToInt() - q.ConvertToInt();
+                int64_t fval = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout / qout.ConvertToDouble() * Q.ConvertToDouble()));
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTposfull = [fLUTpos](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUTpos(x, q, Q);
+            else
+                return (Q - fLUTpos((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        auto fLUTnegfull = [fLUTneg](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x >= q / 2)
+                return fLUTneg(x, q, Q);
+            else
+                return (Q - fLUTneg((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        auto fLUTsgn = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return Q / 8;
+            else
+                return Q - Q / 8;
+        };
+        LWECiphertext ct_pos, ct_neg, ct_sgn;
+        if (multithread) {
+#pragma omp parallel for num_threads(3)
+            for (size_t i = 0; i < 3; i++) {
+                if (i == 0)
+                    ct_pos = BootstrapFunc(params, EK, ct, fLUTposfull, Q, true);
+                else if (i == 1)
+                    ct_neg = BootstrapFunc(params, EK, ct, fLUTnegfull, Q, true);
+                else
+                    ct_sgn = BootstrapFunc(params, EK, ct, fLUTsgn, q);
+            }
+        }
+        else {
+            ct_pos = BootstrapFunc(params, EK, ct, fLUTposfull, Q, true);
+            ct_neg = BootstrapFunc(params, EK, ct, fLUTnegfull, Q, true);
+            ct_sgn = BootstrapFunc(params, EK, ct, fLUTsgn, q);
+        }
+        auto packed_tv =
+            FunctionalKeySwitch(params, EK.PKkey_half, N / 2,
+                                {std::make_pair(ct_pos, size_t(3 * N / 2)), std::make_pair(ct_neg, size_t(0))});
+        auto ct_sel = BootstrapCtxt(params, EK, ct_sgn, packed_tv, q, false, false);
+        return LWEscheme->ModSwitch(qout, ct_sel);
     }
 
-    const auto curBase = RGSWParams->GetBaseG();
-    auto search        = EKs.find(curBase);
-    if (search == EKs.end()) {
-        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
-        OPENFHE_THROW(openfhe_error, errMsg);
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
     }
-    RingGSWBTKey curEK(search->second);
 
-    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
-    std::vector<LWECiphertext> ret;
-    while (mod > q) {
-        auto ctq = std::make_shared<LWECiphertextImpl>(*cttmp);
-        ctq->SetModulus(q);
-        ret.push_back(std::move(ctq));
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
 
-        // Floor the input sequentially to obtain the most significant bit
-        cttmp = EvalFloor(params, curEK, cttmp, beta);
-        mod   = mod / q * 2 * beta;
-        // round Q to 2betaQ/q
-        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+    // NOTE: we don't choose to output Q - LUT[xxx] for negative values, because tv1's can either be viewed modulo Q or modulo p
+    //  if we output p - LUT[xxx], the value of fLUT's will lie in [0,p-1]
+    //  if we output Q - LUT[xxx], the value of fLUT's will iie in [-p+1,p-1], doubling the std of noise
+    // NOTE: the third param is not used, its only usage is to fit into BootstrapFunc's API
+    auto fLUTpos = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTneg = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x >= q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTsgn = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x <
+            q / 2)  // NOTE: what if 8 does not divide p? A: some more error in the evaluated sign, but won't affect the correctness of FDFB-Select
+            return p / 8;
+        else
+            return p - p / 8;
+    };
 
-        if (EKs.size() == 3) {  // if dynamic
-            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
-            uint32_t base   = 0;
-            if (binLog <= static_cast<uint32_t>(17))
-                base = static_cast<uint32_t>(1) << 27;
-            else if (binLog <= static_cast<uint32_t>(26))
-                base = static_cast<uint32_t>(1) << 18;
+    LWECiphertext ct_pos, ct_neg, ct_sgn;
 
-            if (0 != base) {  // if base is to change ...
-                RGSWParams->Change_BaseG(base);
+    if (use_multi_value_bts) {
+        auto rlwe_prime = PrepareRLWEPrime(params, EK, ct1, beta, p, false);  // NOTE: beta here
 
-                auto search = EKs.find(base);
-                if (search == EKs.end()) {
-                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
-                    OPENFHE_THROW(openfhe_error, errMsg);
-                }
-                curEK = search->second;
+        NativeVector tv1_pos(N, p);
+        NativeVector tv1_neg(N, p);
+        NativeVector tv1_sgn(N, p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp   = NativeInteger(0).ModSub(i, dN);
+            tv1_pos[i] = fLUTpos(tmp, dN, p);
+            tv1_neg[i] = fLUTneg(tmp, dN, p);
+            tv1_sgn[i] = fLUTsgn(tmp, dN, p);
+        }
+        // TODO: directly find the transition points rather than compute the difference? but the overhead here is negligible compared to blind rotation
+        tv1_pos = ComputeTV1(tv1_pos);
+        tv1_neg = ComputeTV1(tv1_neg);
+        tv1_sgn = ComputeTV1(tv1_sgn);
+        tv1_pos.SwitchModulus(Q);
+        tv1_neg.SwitchModulus(Q);
+        tv1_sgn.SwitchModulus(Q);
+        NativePoly poly_pos(polyparams), poly_neg(polyparams), poly_sgn(polyparams);
+        poly_pos.SetValues(tv1_pos, Format::COEFFICIENT);
+        poly_neg.SetValues(tv1_neg, Format::COEFFICIENT);
+        poly_sgn.SetValues(tv1_sgn, Format::COEFFICIENT);
+
+        auto acc_pos = InnerProduct(rlwe_prime, SignedDecomp(params, poly_pos, 2 * p, baseGMV)),
+             acc_neg = InnerProduct(rlwe_prime, SignedDecomp(params, poly_neg, 2 * p, baseGMV)),
+             acc_sgn = InnerProduct(rlwe_prime, SignedDecomp(params, poly_sgn, 2 * p, baseGMV));
+
+        // extract LWE ciphertext
+        ct_pos = ExtractACC(acc_pos);
+        ct_neg = ExtractACC(acc_neg);
+        ct_sgn = ExtractACC(acc_sgn);
+        // bring ct_sgn to (q,n,sk) so that it can be used as the selector for next bootstrapping
+        ct_sgn = LWEscheme->ModSwitch(qKS, ct_sgn);
+        ct_sgn = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_sgn);
+        ct_sgn = LWEscheme->ModSwitch(q, ct_sgn);  // ct_sgn is in (-3q/4, 0) when msb = 1, and in (0, 4/q) when msb = 0
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(3)
+            for (size_t i = 0; i < 3; i++) {
+                if (i == 0)
+                    ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+                else if (i == 1)
+                    ct_neg = BootstrapFunc(params, EK, ct1, fLUTneg, p, true);
+                else
+                    ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, p, true);
             }
         }
+        else {
+            ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+            ct_neg = BootstrapFunc(params, EK, ct1, fLUTneg, p, true);
+            ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, p, true);
+        }
+        ct_sgn = LWEscheme->ModSwitch(qKS, ct_sgn);
+        ct_sgn = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_sgn);
+        ct_sgn = LWEscheme->ModSwitch(q, ct_sgn);  // ct_sgn is in (-3q/4, 0) when msb = 1, and in (0, 4/q) when msb = 0
     }
-    LWEscheme->EvalAddConstEq(cttmp, beta);
-
-    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
-        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
-    };
-    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
-    RGSWParams->Change_BaseG(curBase);
-    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
-    ret.push_back(std::move(cttmp));
-    return ret;
+    // functional KS
+    auto packed_tv =
+        FunctionalKeySwitch(params, EK.PKkey_half, N / 2,
+                            {std::make_pair(ct_pos, size_t(3 * N / 2 + 1)), std::make_pair(ct_neg, size_t(1))});
+    auto baseG_bak = RGSWparams->GetBaseG();
+    RGSWparams->Change_BaseG(baseG_small);
+    auto ct_sel = BootstrapCtxt(params, EK_small, ct_sgn, packed_tv, q);
+    RGSWparams->Change_BaseG(baseG_bak);
+    return ct_sel;
 }
 
-// private:
+LWECiphertext BinFHEScheme::EvalFuncSelectAlt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                              ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                              const NativeInteger beta, double deltain, double deltaout,
+                                              NativeInteger qout, double (*f)(double m), const RingGSWBTKey& EK_small,
+                                              uint32_t baseG_small) const {
+    // always full range
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto Q           = LWEParams->GetQ();
+    auto N           = LWEParams->GetN();
+    auto qKS         = LWEParams->GetqKS();
+    auto baseGMV     = RGSWparams->GetBaseGMV();
+    auto polyparams  = params->GetRingGSWParams()->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1                 = std::make_shared<LWECiphertextImpl>(*ct);
+    bool use_multi_value_bts = baseGMV > 0;
 
-RLWECiphertext BinFHEScheme::BootstrapGateCore(const std::shared_ptr<BinFHECryptoParams> params, BINGATE gate,
-                                               const RingGSWACCKey ek, ConstLWECiphertext ct) const {
-    if (ek == nullptr) {
-        std::string errMsg =
-            "Bootstrapping keys have not been generated. Please call BTKeyGen "
-            "before calling bootstrapping.";
-        OPENFHE_THROW(config_error, errMsg);
+    NativeInteger q = ct->GetModulus();
+    if (f !=
+        nullptr) {  // NOTE: for CKKS-extracted LWE ciphertext, we do not use multi-value bootstrap to accelerate it, since the error analysis is quite tricky and function dependant
+        if (use_multi_value_bts)
+            OPENFHE_THROW(
+                openfhe_error,
+                "using multi-value bootstrap to accelerate FDFB-Select on CKKS-extracted ciphertexts is not supported");
+        if (qout == 0)
+            qout = q;
+
+        auto fLUTpos = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                    NativeInteger Q) -> NativeInteger {
+            if (x < q / 2) {
+                int64_t xin  = x.ConvertToInt();
+                int64_t fval = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout / qout.ConvertToDouble() * Q.ConvertToDouble()));
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTneg = [f, deltain, deltaout, qout](NativeInteger x, NativeInteger q,
+                                                    NativeInteger Q) -> NativeInteger {
+            if (x >= q / 2) {
+                int64_t xin  = x.ConvertToInt() - q.ConvertToInt();
+                int64_t fval = static_cast<int64_t>(
+                    std::round(f(xin / deltain) * deltaout / qout.ConvertToDouble() * Q.ConvertToDouble()));
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+        };
+        auto fLUTposfull = [fLUTpos](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUTpos(x, q, Q);
+            else
+                return (Q - fLUTpos((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        auto fLUTnegfull = [fLUTneg](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+            if (x >= q / 2)
+                return fLUTneg(x, q, Q);
+            else
+                return (Q - fLUTneg((x + q / 2).Mod(q), q, Q)).Mod(Q);
+        };
+        // XXX: try new
+        // (TVneg - TVpos)/2
+        // auto fLUThalfdiff = [fLUTposfull, fLUTnegfull](NativeInteger x, NativeInteger q,
+        //                                                NativeInteger Q) -> NativeInteger {
+        //     return fLUTnegfull(x, q, Q).ModSubFast(fLUTposfull(x, q, Q), Q) >> 1;
+        // };
+
+        NativePoly tv_hdiff(polyparams, Format::COEFFICIENT, true), tv_hsum(polyparams, Format::COEFFICIENT, true);
+        NativePoly dummy_1(polyparams, Format::COEFFICIENT, true), dummy_2(polyparams, Format::COEFFICIENT, true);
+        for(size_t i = 0; i < N; i++){
+            NativeInteger tmp = NativeInteger(0).ModSubFast(i, q);
+            int64_t pos_coeff = fLUTposfull(tmp, q, Q).ConvertToInt(), neg_coeff = fLUTnegfull(tmp, q, Q).ConvertToInt();
+            int64_t hdiff_coeff = (neg_coeff - pos_coeff) / 2, hsum_coeff = (neg_coeff + pos_coeff) / 2;
+            if(hdiff_coeff < 0)
+                hdiff_coeff += Q.ConvertToInt();
+            tv_hdiff[i] = hdiff_coeff;
+            tv_hsum[i] = hsum_coeff;
+        }
+
+        LWECiphertext ct_hdiff, ct_hsum;
+        ct_hdiff = BootstrapCtxt(params, EK, ct, std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_1, tv_hdiff}), 0, true);
+        ct_hsum = BootstrapCtxt(params, EK, ct, std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_2, tv_hsum}), 0, true);
+        
+        auto packed_tv = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(ct_hdiff, N + 1)});
+        auto ct_sgn_hdiff = BootstrapCtxt(params, EK, ct, packed_tv, 0, true);
+        LWEscheme->EvalSubEq(ct_hsum, ct_sgn_hdiff);
+        // postprocessing
+        ct_hsum = LWEscheme->ModSwitch(qKS, ct_hsum);
+        ct_hsum = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_hsum);
+        return LWEscheme->ModSwitch(qout, ct_hsum);
+
+//         LWECiphertext ct_pos, ct_diff;
+//         if (multithread) {
+// #pragma omp parallel for num_threads(2)
+//             for (size_t i = 0; i < 2; i++) {
+//                 if (i == 0)
+//                     ct_pos = BootstrapFunc(params, EK, ct, fLUTposfull, Q, true);
+//                 else if (i == 1)
+//                     ct_diff = BootstrapFunc(params, EK, ct, fLUThalfdiff, Q, true);
+//             }
+//         }
+//         else {
+//             ct_pos  = BootstrapFunc(params, EK, ct, fLUTposfull, Q, true);
+//             ct_diff = BootstrapFunc(params, EK, ct, fLUThalfdiff, Q, true);
+//         }
+//         auto packed_tv  = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(ct_diff, N + 1)});
+//         auto ct_sgndiff = BootstrapCtxt(params, EK, ct, packed_tv, q, true);
+//         LWEscheme->EvalSubEq(ct_diff, ct_sgndiff);
+//         LWEscheme->EvalAddEq(ct_diff, ct_pos);
+        // postprocessing
+        // ct_diff = LWEscheme->ModSwitch(qKS, ct_diff);
+        // ct_diff = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_diff);
+        // return LWEscheme->ModSwitch(qout, ct_diff);
+    }
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
     }
 
-    auto& LWEParams  = params->GetLWEParams();
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+
+    // NOTE: we don't choose to output Q - LUT[xxx] for negative values, because tv1's can either be viewed modulo Q or modulo p
+    //  if we output p - LUT[xxx], the value of fLUT's will lie in [0,p-1]
+    //  if we output Q - LUT[xxx], the value of fLUT's will iie in [-p+1,p-1], doubling the std of noise
+    // NOTE: the third param is not used, its only usage is to fit into BootstrapFunc's API
+    auto fLUTpos = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTneg = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x >= q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUThalfdiff = [fLUTpos, fLUTneg, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return fLUTneg(x, q, Q).ModSubFast(fLUTpos(x, q, Q), p);
+    };
+
+    LWECiphertext ct_pos, ct_diff;
+
+    if (use_multi_value_bts) {
+        // set baseGMV >= 4p for this work... TODO: update API?
+        // NOTE: generate Q/4p*(1+X+...)*X^m * {(1-sgn) * (TV1neg - TV1pos) or 2TV1pos}
+        auto rlwe_prime = PrepareRLWEPrime(params, EK, ct1, beta, 2 * p, false);
+
+        NativeVector tv1_pos(N, p);
+        NativeVector tv1_diff(N, p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp    = NativeInteger(0).ModSub(i, dN);
+            tv1_pos[i]  = fLUTpos(tmp, dN, 0);
+            tv1_diff[i] = fLUThalfdiff(tmp, dN, 0);
+        }
+        // TODO: directly find the transition points rather than compute the difference? but the overhead here is negligible compared to blind rotation
+        tv1_pos  = ComputeTV1(tv1_pos);
+        tv1_diff = ComputeTV1(tv1_diff);
+        tv1_pos.SetModulus(Q);
+        tv1_diff.SetModulus(Q);
+        NativePoly poly_pos(polyparams), poly_diff(polyparams);
+        poly_pos.SetValues(tv1_pos, Format::COEFFICIENT);
+        poly_diff.SetValues(tv1_diff, Format::COEFFICIENT);
+
+        auto acc_pos =
+                 InnerProduct(rlwe_prime, SignedDecomp(params, poly_pos, 2 * p, 2 * p)),  // NOTE: no decomp here...
+            acc_diff = InnerProduct(rlwe_prime, SignedDecomp(params, poly_diff, 2 * p, 2 * p));
+
+        // extract LWE ciphertext
+        ct_pos  = ExtractACC(acc_pos);
+        ct_diff = ExtractACC(acc_diff);
+        LWEscheme->EvalMultConstEq(ct_pos, 2);  // 2 TVpos
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(2)
+            for (size_t i = 0; i < 2; i++) {
+                if (i == 0)
+                    ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+                else if (i == 1)
+                    ct_diff = BootstrapFunc(params, EK, ct1, fLUThalfdiff, 2 * p, true);
+            }
+        }
+        else {
+            ct_pos  = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+            ct_diff = BootstrapFunc(params, EK, ct1, fLUThalfdiff, 2 * p, true);
+        }
+    }
+    // functional KS
+    auto packed_tv = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(ct_diff, N + 1)});
+    auto baseG_bak = RGSWparams->GetBaseG();
+    RGSWparams->Change_BaseG(baseG_small);
+    auto ct_sgndiff = BootstrapCtxt(params, EK_small, ct1, packed_tv, q, true);
+    RGSWparams->Change_BaseG(baseG_bak);
+    LWEscheme->EvalSubEq(ct_diff, ct_sgndiff);
+    LWEscheme->EvalAddEq(ct_diff, ct_pos);
+    // postprocessing
+    ct_diff = LWEscheme->ModSwitch(qKS, ct_diff);
+    ct_diff = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_diff);
+    return LWEscheme->ModSwitch(q, ct_diff);
+}
+
+LWECiphertext BinFHEScheme::EvalFuncPreSelect(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                              ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                              const NativeInteger beta, double deltain, double deltaout,
+                                              NativeInteger qout, double (*f)(double m), NativeInteger p_mid) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    uint32_t N       = LWEParams->GetN();
+    uint32_t baseG0  = RGSWparams->GetBaseG0();
+    NativeInteger Q  = LWEParams->GetQ();
+    auto polyparams  = RGSWparams->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    // Get what time of function it is
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        if (qout == 0)
+            qout = q;
+        if (p_mid == 0)
+            p_mid = q;
+        size_t d_G0 = static_cast<size_t>(std::ceil(log(p_mid.ConvertToDouble()) / log(double(baseG0))));
+        std::vector<std::pair<NativeInteger, NativeInteger>> pn_values(d_G0);
+        uint128_t Q_128 = static_cast<uint128_t>(Q.ConvertToInt()),
+                  p_128 = static_cast<uint128_t>(p_mid.ConvertToInt());
+        uint128_t power = 1;
+        for (size_t i = 0; i < d_G0; i++, power *= baseG0) {  // generate (MSB==1)*Q/p*B^i
+            pn_values[i].first  = 0;
+            pn_values[i].second = static_cast<uint64_t>((Q_128 * power + p_128 / 2) / p_128);
+        }
+        auto batch_sel_res = BatchSelect(params, EK, ct1, beta, pn_values);
+        std::vector<RLWECiphertext> rlwe_prime(d_G0);
+        if (multithread) {
+            omp_set_nested(1);  // NOTE: enable nested parallelism for FunctionalKS
+#pragma omp parallel for num_threads(d_G0)
+            for (
+                size_t i = 0; i < d_G0;
+                i++) {  // generate (MSB==1)*Q/p*B^i // NOTE: we can also use TV0*TV1 decomposition and generate (MSB==1)*Q/2p*B^i*(1+X+...+X^{N-1})
+                rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(batch_sel_res[i], 0)});
+                rlwe_prime[i]->SetFormat(Format::EVALUATION);
+            }
+        }
+        else {
+            for (size_t i = 0; i < d_G0; i++) {  // generate (MSB==1)*Q/p*B^i
+                rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(batch_sel_res[i], 0)});
+                rlwe_prime[i]->SetFormat(Format::EVALUATION);
+            }
+        }
+
+        // poly x RLWE' multiplication: [MSB==1] * ((poly_neg - poly_pos) mod p) + poly_pos
+        auto fLUTpos = [p_mid, f, deltain, deltaout, qout](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x < q / 2) {
+                int64_t fval = std::round(f(x.ConvertToDouble() / deltain) * deltaout * p_mid.ConvertToDouble() /
+                                          qout.ConvertToDouble());
+                fval %= p_mid.ConvertToInt();
+                if (fval < 0)
+                    fval += p_mid.ConvertToInt();
+                return fval;
+            }
+            else {
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+            }
+        };
+        auto fLUTneg = [p_mid, f, deltain, deltaout, qout](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x >= q / 2) {
+                // NOTE: use x - q here, because x represents a negative value
+                int64_t fval = std::round(f((x.ConvertToDouble() - q.ConvertToDouble()) / deltain) * deltaout *
+                                          p_mid.ConvertToDouble() / qout.ConvertToDouble());
+                fval %= p_mid.ConvertToInt();
+                if (fval < 0)
+                    fval += p_mid.ConvertToInt();
+                return fval;
+            }
+            else {
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+            }
+        };
+        auto fLUTpos_full = [fLUTpos, p_mid](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUTpos(x, q);
+            else
+                return (p_mid - fLUTpos((x + q / 2).Mod(q), q)).Mod(p_mid);
+        };
+        auto fLUTneg_full = [fLUTneg, p_mid](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x >= q / 2)
+                return fLUTneg(x, q);
+            else
+                return (p_mid - fLUTneg((x + q / 2).Mod(q), q)).Mod(p_mid);
+        };
+
+        NativePoly poly_pos(polyparams, Format::COEFFICIENT, true), poly_neg(polyparams, Format::COEFFICIENT, true);
+        for (size_t i = 0, dN = N * 2; i < N; i++) {
+            poly_pos[i] = fLUTpos_full(NativeInteger(0).ModSub(i, dN), dN);
+            poly_neg[i] = fLUTneg_full(NativeInteger(0).ModSub(i, dN), dN);
+        }
+
+        auto poly_diff = poly_neg - poly_pos;
+        for (size_t i = 0; i < N; i++) {
+            // reduce to [-pmid/2, pmid/2-1]
+            if (poly_diff[i] < Q - p_mid / 2)
+                poly_diff[i].ModAddFastEq(p_mid, Q);
+            else if (poly_diff[i] >= p_mid / 2)
+                poly_diff[i].ModSubFastEq(p_mid, Q);
+        }
+
+        auto decomp_poly_diff = SignedDecomp(params, poly_diff, p_mid.ConvertToInt(), baseG0);
+
+        // mult
+        RLWECiphertext ct_prod = InnerProduct(rlwe_prime, decomp_poly_diff);
+        ct_prod->GetElements()[0].SetFormat(Format::COEFFICIENT);
+        ct_prod->GetElements()[1].SetFormat(Format::COEFFICIENT);
+
+        NativeVector vec_pos = poly_pos.GetValues();
+        vec_pos.SetModulus(p_mid);
+        NativePoly scaled_poly_pos(polyparams);
+        scaled_poly_pos.SetValues(ModSwitch(Q, vec_pos), Format::COEFFICIENT);
+        ct_prod->GetElements()[1] += scaled_poly_pos;
+        // blind rotate
+        return BootstrapCtxt(params, EK, ct1, ct_prod, qout);
+    }
+
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+    // arbitary funciton
+    // Phase preprocessing
+    // 1. bts([m]) -> [sgn]
+    // 2. prepare packed poly of {0,1}*Q/p*B^i, for i = 0, 1, ..., d_G0 - 1
+    // 3. bts([sgn]) -> multiple LWE ciphertexts encrypting (MSB==1)*Q/p*B^i
+    // 4. LWE to RLWE packing (only constant term) -> RLWE' ciphertext encrypting {(MSB==1)*Q/p*B^i}
+    // Phase online
+    // 5. Decomp(poly) x RLWE' -> selected ciphertext [TV*]
+    // 6. bts([TV*]) -> [f(m)]
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+    size_t d_G0 = static_cast<size_t>(std::ceil(log(double(2 * p)) / log(double(baseG0))));
+    std::vector<std::pair<NativeInteger, NativeInteger>> pn_values(d_G0);
+    uint128_t Q_128 = static_cast<uint128_t>(Q.ConvertToInt()), p_128 = static_cast<uint128_t>(p),
+              dp_128 = static_cast<uint128_t>(2 * p);
+    uint128_t power  = 1;
+    for (size_t i = 0; i < d_G0; i++, power *= baseG0) {  // generate (MSB==1)*Q/2p*B^i
+        pn_values[i].first  = 0;
+        pn_values[i].second = static_cast<uint64_t>((Q_128 * power + p_128) / dp_128);
+    }
+    auto batch_sel_res = BatchSelect(params, EK, ct1, beta, pn_values);  // NOTE: here beta is the precise beta
+    std::vector<RLWECiphertext> rlwe_prime(d_G0);
+    if (multithread) {
+        omp_set_nested(1);  // NOTE: enable nested parallelism for FunctionalKS
+#pragma omp parallel for num_threads(d_G0)
+        for (size_t i = 0; i < d_G0; i++) {  // generate (MSB==1)*Q/2p*B^i*(1+X+X^2+...+X^(N-1))
+            rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(batch_sel_res[i], 0)});
+            rlwe_prime[i]->SetFormat(Format::EVALUATION);
+        }
+    }
+    else {
+        for (size_t i = 0; i < d_G0; i++) {  // generate (MSB==1)*Q/2p*B^i*(1+X+X^2+...+X^(N-1))
+            rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(batch_sel_res[i], 0)});
+            rlwe_prime[i]->SetFormat(Format::EVALUATION);
+        }
+    }
+    // poly x RLWE' multiplication: [MSB==1] * ((poly_neg - poly_pos) mod 2p) + poly_pos
+    auto fLUT_pos = [LUT, p](NativeInteger x, NativeInteger q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUT_neg = [LUT, p](NativeInteger x, NativeInteger q) -> NativeInteger {
+        if (x >= q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    NativeVector tv1_pos(N, p), tv1_neg(N, p);
+    for (size_t i = 0, dN = N * 2; i < N; i++) {
+        tv1_pos[i] = fLUT_pos(NativeInteger(0).ModSub(i, dN), dN);
+        tv1_neg[i] = fLUT_neg(NativeInteger(0).ModSub(i, dN), dN);
+    }
+    NativeVector vec_pos  = tv1_pos;
+    tv1_pos               = ComputeTV1(tv1_pos);
+    tv1_neg               = ComputeTV1(tv1_neg);
+    NativeVector tv1_diff = tv1_neg - tv1_pos;
+    tv1_diff.SetModulus(Q);
+    NativePoly poly_diff(polyparams);
+    poly_diff.SetValues(tv1_diff, Format::COEFFICIENT);
+
+    // NativePoly poly_pos(polyparams, Format::COEFFICIENT, true), poly_neg(polyparams, Format::COEFFICIENT, true);
+    // for (size_t i = 0, dN = N * 2; i < N; i++) {
+    //     poly_pos[i] = fLUT_pos(NativeInteger(0).ModSub(i, dN), dN);
+    //     poly_neg[i] = fLUT_neg(NativeInteger(0).ModSub(i, dN), dN);
+    // }
+    // NativeVector vec_pos = poly_pos.GetValues();
+    // vec_pos.SetModulus(p);
+
+    // poly_pos -= poly_pos.ShiftRightNegacyclic(1);
+    // poly_neg -= poly_neg.ShiftRightNegacyclic(1);
+    // auto decomp_poly_diff = SignedDecomp(params, poly_neg - poly_pos, 2 * p, baseG0);
+    auto decomp_poly_diff = SignedDecomp(params, poly_diff, 2 * p, baseG0);
+
+    // mult
+    RLWECiphertext ct_prod = InnerProduct(rlwe_prime, decomp_poly_diff);
+    ct_prod->GetElements()[0].SetFormat(Format::COEFFICIENT);
+    ct_prod->GetElements()[1].SetFormat(Format::COEFFICIENT);
+
+    NativePoly scaled_poly_pos(polyparams);
+    scaled_poly_pos.SetValues(ModSwitch(Q, vec_pos), Format::COEFFICIENT);
+    ct_prod->GetElements()[1] += scaled_poly_pos;
+    // blind rotate
+    return BootstrapCtxt(params, EK, ct1, ct_prod, q);
+}
+
+// NOTE: copied from EvalFuncPreselec
+LWECiphertext BinFHEScheme::EvalFuncKS21(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                         ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                         const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                         double (*f)(double m)) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    uint32_t N       = LWEParams->GetN();
+    uint32_t baseG0  = RGSWparams->GetBaseG0();
+    NativeInteger Q  = LWEParams->GetQ();
+    auto polyparams  = RGSWparams->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    // Get what time of function it is
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        if (qout == 0)
+            qout = q;
+        size_t d_G0 = static_cast<size_t>(std::ceil(log(Q.ConvertToDouble()) / log(double(baseG0))));
+        std::vector<std::pair<NativeInteger, NativeInteger>> pn_values(d_G0);
+        // uint128_t Q_128 = static_cast<uint128_t>(Q.ConvertToInt()), p_128 = static_cast<uint128_t>(p),
+        //           dp_128 = static_cast<uint128_t>(2 * p);
+        std::vector<RLWECiphertext> rlwe_prime(d_G0);
+        std::vector<uint128_t> powers_Bg0(d_G0);
+        uint128_t tmp_power = 1;
+        for (size_t i = 0; i < d_G0; i++, tmp_power *= baseG0)
+            powers_Bg0[i] = tmp_power;
+        if (multithread) {
+            omp_set_nested(1);  // NOTE: enable nested parallelism for FunctionalKS
+#pragma omp parallel for num_threads(d_G0)
+            for (size_t i = 0; i < d_G0; i++) {
+                // first compute SGN*B^i/2
+                // then compute MSB*B^i = (1-SGN)*B^i/2
+                // the use KS to compute SGN*B^i
+                NativePoly tmp_tv(polyparams, Format::COEFFICIENT, true);
+                NativePoly dummy_a(polyparams, Format::COEFFICIENT, true);
+                NativeInteger tmp_coeff     = powers_Bg0[i] / 2;
+                NativeInteger tmp_coeff_neg = -tmp_coeff;
+                tmp_tv[0]                   = tmp_coeff_neg;
+                for (size_t j = 1; j < N; j++)  // MSB=0 -> -B^i/2; MSB=1 -> B^i/2
+                    tmp_tv[j] = tmp_coeff;
+                auto tmp_ctxt = BootstrapCtxt(
+                    params, EK, ct1, std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_a, tmp_tv}), Q,
+                    true);
+                LWEscheme->EvalAddConstEq(tmp_ctxt, tmp_coeff);
+                rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(tmp_ctxt, 0)});
+                rlwe_prime[i]->SetFormat(Format::EVALUATION);
+            }
+        }
+        else {
+            for (size_t i = 0; i < d_G0; i++) {  // generate (MSB==1)*B^i/2
+                // first compute SGN*B^i/2
+                // then compute MSB*B^i = (1-SGN)*B^i/2
+                // the use KS to compute SGN*B^i
+                NativePoly tmp_tv(polyparams, Format::COEFFICIENT, true);
+                NativePoly dummy_a(polyparams, Format::COEFFICIENT, true);
+                NativeInteger tmp_coeff     = powers_Bg0[i] / 2;
+                NativeInteger tmp_coeff_neg = -tmp_coeff;
+                tmp_tv[0]                   = tmp_coeff_neg;
+                for (size_t j = 1; j < N; j++)  // MSB=0 -> -B^i/2; MSB=1 -> B^i/2
+                    tmp_tv[j] = tmp_coeff;
+                auto tmp_ctxt = BootstrapCtxt(
+                    params, EK, ct1, std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_a, tmp_tv}), Q,
+                    true);
+                LWEscheme->EvalAddConstEq(tmp_ctxt, tmp_coeff);
+                rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(tmp_ctxt, 0)});
+                rlwe_prime[i]->SetFormat(Format::EVALUATION);
+            }
+        }
+
+        // poly x RLWE' multiplication: [MSB==1] * ((poly_neg - poly_pos) mod p) + poly_pos
+        auto fLUTpos = [Q, f, deltain, deltaout, qout](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x < q / 2) {
+                int64_t fval = std::round(f(x.ConvertToDouble() / deltain) * deltaout * Q.ConvertToDouble() /
+                                          qout.ConvertToDouble());
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else {
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+            }
+        };
+        auto fLUTneg = [Q, f, deltain, deltaout, qout](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x >= q / 2) {
+                // NOTE: use x - q here, because x represents a negative value
+                int64_t fval = std::round(f((x.ConvertToDouble() - q.ConvertToDouble()) / deltain) * deltaout *
+                                          Q.ConvertToDouble() / qout.ConvertToDouble());
+                fval %= Q.ConvertToInt();
+                if (fval < 0)
+                    fval += Q.ConvertToInt();
+                return fval;
+            }
+            else {
+                OPENFHE_THROW(openfhe_error, "this branch should not have been reached");
+            }
+        };
+        auto fLUTpos_full = [fLUTpos, Q](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x < q / 2)
+                return fLUTpos(x, q);
+            else
+                return (Q - fLUTpos((x + q / 2).Mod(q), q)).Mod(Q);
+        };
+        auto fLUTneg_full = [fLUTneg, Q](NativeInteger x, NativeInteger q) -> NativeInteger {
+            if (x >= q / 2)
+                return fLUTneg(x, q);
+            else
+                return (Q - fLUTneg((x + q / 2).Mod(q), q)).Mod(Q);
+        };
+
+        NativePoly poly_pos(polyparams, Format::COEFFICIENT, true), poly_neg(polyparams, Format::COEFFICIENT, true);
+        for (size_t i = 0, dN = N * 2; i < N; i++) {
+            poly_pos[i] = fLUTpos_full(NativeInteger(0).ModSub(i, dN), dN);
+            poly_neg[i] = fLUTneg_full(NativeInteger(0).ModSub(i, dN), dN);
+        }
+
+        auto poly_diff = poly_neg - poly_pos;
+
+        auto decomp_poly_diff = SignedDecomp(params, poly_diff, Q.ConvertToInt(), baseG0);
+
+        // mult
+        RLWECiphertext ct_prod = InnerProduct(rlwe_prime, decomp_poly_diff);
+        ct_prod->GetElements()[0].SetFormat(Format::COEFFICIENT);
+        ct_prod->GetElements()[1].SetFormat(Format::COEFFICIENT);
+        ct_prod->GetElements()[1] += poly_pos;
+        // blind rotate
+        auto ct_res = BootstrapCtxt(params, EK, ct1, ct_prod, Q, false, false);
+        return LWEscheme->ModSwitch(qout, ct_res);
+        // TODO: test
+    }
+
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+    // arbitary funciton
+    // Phase preprocessing
+    // 1. bts([m]) -> [sgn]
+    // 2. prepare packed poly of {0,1}*Q/p*B^i, for i = 0, 1, ..., d_G0 - 1
+    // 3. bts([sgn]) -> multiple LWE ciphertexts encrypting (MSB==1)*Q/p*B^i
+    // 4. LWE to RLWE packing (only constant term) -> RLWE' ciphertext encrypting {(MSB==1)*Q/p*B^i}
+    // Phase online
+    // 5. Decomp(poly) x RLWE' -> selected ciphertext [TV*]
+    // 6. bts([TV*]) -> [f(m)]
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+    size_t d_G0 = static_cast<size_t>(std::ceil(log(Q.ConvertToDouble()) / log(double(baseG0))));
+    // uint128_t Q_128 = static_cast<uint128_t>(Q.ConvertToInt()), p_128 = static_cast<uint128_t>(p),
+    //           dp_128 = static_cast<uint128_t>(2 * p);
+    std::vector<RLWECiphertext> rlwe_prime(d_G0);
+    std::vector<uint128_t> powers_Bg0(d_G0);
+    uint128_t tmp_power = 1;
+    for (size_t i = 0; i < d_G0; i++, tmp_power *= baseG0)
+        powers_Bg0[i] = tmp_power;
+    if (multithread) {
+        omp_set_nested(1);  // NOTE: enable nested parallelism for FunctionalKS
+#pragma omp parallel for num_threads(d_G0)
+        for (size_t i = 0; i < d_G0; i++) {
+            // first compute SGN*B^i/2
+            // then compute MSB*B^i = (1-SGN)*B^i/2
+            // the use KS to compute SGN*B^i
+            NativePoly tmp_tv(polyparams, Format::COEFFICIENT, true);
+            NativePoly dummy_a(polyparams, Format::COEFFICIENT, true);
+            NativeInteger tmp_coeff     = powers_Bg0[i] / 2;
+            NativeInteger tmp_coeff_neg = -tmp_coeff;
+            tmp_tv[0]                   = tmp_coeff_neg;
+            for (size_t j = 1; j < N; j++)  // MSB=0 -> -B^i/2; MSB=1 -> B^i/2
+                tmp_tv[j] = tmp_coeff;
+            auto tmp_ctxt =
+                BootstrapCtxt(params, EK, ct1,
+                              std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_a, tmp_tv}), Q, true);
+            LWEscheme->EvalAddConstEq(tmp_ctxt, tmp_coeff);
+            rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(tmp_ctxt, 0)});
+            rlwe_prime[i]->SetFormat(Format::EVALUATION);
+        }
+    }
+    else {
+        for (size_t i = 0; i < d_G0; i++) {  // generate (MSB==1)*B^i/2
+            // first compute SGN*B^i/2
+            // then compute MSB*B^i = (1-SGN)*B^i/2
+            // the use KS to compute SGN*B^i
+            NativePoly tmp_tv(polyparams, Format::COEFFICIENT, true);
+            NativePoly dummy_a(polyparams, Format::COEFFICIENT, true);
+            NativeInteger tmp_coeff     = powers_Bg0[i] / 2;
+            NativeInteger tmp_coeff_neg = -tmp_coeff;
+            tmp_tv[0]                   = tmp_coeff_neg;
+            for (size_t j = 1; j < N; j++)  // MSB=0 -> -B^i/2; MSB=1 -> B^i/2
+                tmp_tv[j] = tmp_coeff;
+            auto tmp_ctxt =
+                BootstrapCtxt(params, EK, ct1,
+                              std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{dummy_a, tmp_tv}), Q, true);
+            LWEscheme->EvalAddConstEq(tmp_ctxt, tmp_coeff);
+            rlwe_prime[i] = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(tmp_ctxt, 0)});
+            rlwe_prime[i]->SetFormat(Format::EVALUATION);
+        }
+    }
+    // poly x RLWE' multiplication: [MSB==1] * ((poly_neg - poly_pos) mod 2p) + poly_pos
+    auto fLUT_pos = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return (LUT[(x * p / q).ConvertToInt()] * Q + p / 2) / p;
+        else
+            return ((p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p) * Q + p / 2) / p;
+    };
+    auto fLUT_neg = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x >= q / 2)
+            return (LUT[(x * p / q).ConvertToInt()] * Q + p / 2) / p;
+        else
+            return ((p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p) * Q + p / 2) / p;
+    };
+    NativePoly poly_pos(polyparams, Format::COEFFICIENT, true), poly_neg(polyparams, Format::COEFFICIENT, true);
+    for (size_t i = 0, dN = N * 2; i < N; i++) {
+        poly_pos[i] = fLUT_pos(NativeInteger(0).ModSub(i, dN), dN, Q);
+        poly_neg[i] = fLUT_neg(NativeInteger(0).ModSub(i, dN), dN, Q);
+    }
+    NativePoly poly_diff = poly_neg - poly_pos;
+
+    auto decomp_poly_diff = SignedDecomp(params, poly_diff, Q.ConvertToInt(), baseG0);
+
+    // mult
+    RLWECiphertext ct_prod = InnerProduct(rlwe_prime, decomp_poly_diff);
+    ct_prod->GetElements()[0].SetFormat(Format::COEFFICIENT);
+    ct_prod->GetElements()[1].SetFormat(Format::COEFFICIENT);
+
+    ct_prod->GetElements()[1] += poly_pos;
+    // blind rotate
+    return BootstrapCtxt(params, EK, ct1, ct_prod, q);
+}
+
+LWECiphertext BinFHEScheme::EvalFuncComp(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                         ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                         const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                         double (*f)(double m), uint32_t f_property, double shift,
+                                         const RingGSWBTKey& EK_small, uint32_t baseG_small) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWParams  = params->GetRingGSWParams();
+    auto baseGMV     = RGSWParams->GetBaseGMV();
+    auto N           = LWEParams->GetN();
+    auto Q           = LWEParams->GetQ();
+    auto polyParams  = RGSWParams->GetPolyParams();
+    auto qKS         = LWEParams->GetqKS();
+    bool multithread = params->GetMultithread();
+
+    bool use_multi_value_bts = baseGMV > 0;
+
+    auto q = ct->GetModulus().ConvertToInt();
+    if (f != nullptr) {
+        // f_property: 0 = none, 1 = odd, 2 = even
+        bool enable_odd = f_property != 2, enable_even = f_property != 1;
+        // start computation
+        auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+        // LWEscheme->EvalSubConstEq(ct1, (Q + 2 * q) / (4 * q));
+        LWECiphertext ct_pso, ct_pse;
+        // for pso:
+        // 0 -> beta, q/2-1 -> q/2-beta;
+        // q/2 -> q - beta, q-1 -> q/2+beta
+        // for pse:
+        // 0 -> q/4+beta, q/2-1 -> 3q/4-beta
+        // q/2 -> 3q/4-beta, q-1 -> q/4+beta
+        double slope = (q / 2 - 2 * beta.ConvertToDouble()) / (q / 2 - 1);
+        if (enable_odd) {
+            auto fpso_pre = [beta, slope](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)
+                    return uint64_t(std::round(x.ConvertToDouble() * slope + beta.ConvertToDouble()));
+                else
+                    return (q - uint64_t(std::round((x - q / 2).ConvertToDouble() * slope + beta.ConvertToDouble())))
+                        .Mod(q);
+            };
+            auto ct_pso_pre    = BootstrapFunc(params, EK, ct1, fpso_pre, q);
+            auto fpso_lut_half = [deltain, deltaout, beta, slope, f, qout](NativeInteger x, NativeInteger q,
+                                                                           NativeInteger Q) -> NativeInteger {
+                if (x >= q / 2)
+                    OPENFHE_THROW(openfhe_error, "this branch should not reached");
+                double xin = x.ConvertToDouble();
+                xin        = (xin - beta.ConvertToDouble()) / slope;
+                if (xin < 0)
+                    xin = 0;
+                xin += 0.5;  // compensate for the difference between pseudo-odd and real-odd functions
+                int64_t fval = std::round((f(xin / deltain) - f(-xin / deltain)) / 2 * deltaout * Q.ConvertToDouble() /
+                                          qout.ConvertToDouble());
+                int64_t Qs   = Q.ConvertToInt();
+                fval %= Qs;
+                if (fval < 0)
+                    fval += Qs;
+                return fval;
+            };
+            auto fpso_lut_full = [fpso_lut_half](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)
+                    return fpso_lut_half(x, q, Q);
+                else
+                    return (Q - fpso_lut_half(x - q / 2, q, Q)).Mod(Q);
+            };
+            ct_pso = BootstrapFunc(params, EK, ct_pso_pre, fpso_lut_full, Q, true);
+        }
+        if (enable_even) {
+            auto fpse_pre = [beta, slope](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)
+                    return uint64_t(
+                        std::round(x.ConvertToDouble() * slope + q.ConvertToDouble() / 4 + beta.ConvertToDouble()));
+                else
+                    return (q - uint64_t(std::round((x - q / 2).ConvertToDouble() * slope + q.ConvertToDouble() / 4 +
+                                                    beta.ConvertToDouble())))
+                        .Mod(q);
+            };
+            auto ct_pse_pre = BootstrapFunc(params, EK, ct1, fpse_pre, q);  // in [q/4, 3q/4-1]
+            LWEscheme->EvalSubConstEq(ct_pse_pre, q / 4);                   // in [0,q/2-1]
+            auto fpse_lut_half = [deltain, deltaout, beta, slope, f, qout](NativeInteger x, NativeInteger q,
+                                                                           NativeInteger Q) -> NativeInteger {
+                if (x >= q / 2)
+                    OPENFHE_THROW(openfhe_error, "this branch should not reached");
+                double xin = x.ConvertToDouble();
+                xin        = (xin - beta.ConvertToDouble()) / slope;
+                if (xin < 0)
+                    xin = 0;
+                xin += 0.5;
+                int64_t fval = std::round((f(xin / deltain) + f(-xin / deltain)) / 2 * deltaout * Q.ConvertToDouble() /
+                                          qout.ConvertToDouble());
+                int64_t Qs   = Q.ConvertToInt();
+                fval %= Qs;
+                if (fval < 0)
+                    fval += Qs;
+                return fval;
+            };
+            auto fpse_lut_full = [fpse_lut_half](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)
+                    return fpse_lut_half(x, q, Q);
+                else
+                    return (Q - fpse_lut_half(x - q / 2, q, Q)).Mod(Q);
+            };
+            ct_pse = BootstrapFunc(params, EK, ct_pse_pre, fpse_lut_full, Q, true);
+        }
+        LWECiphertext ct_res;
+        if (enable_odd) {
+            ct_res = ct_pso;
+            if (enable_even)
+                LWEscheme->EvalAddEq(ct_res, ct_pse);
+        }
+        else
+            ct_res = ct_pse;
+        LWEscheme->EvalAddConstEq(
+            ct_res, uint64_t(std::round(Q.ConvertToDouble() / qout.ConvertToDouble() * deltaout * shift)));
+        // bring ct_res back to normal form
+        ct_res = LWEscheme->ModSwitch(qKS, ct_res);
+        ct_res = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_res);
+        return LWEscheme->ModSwitch(qout, ct_res);
+        // TODO: test
+    }
+    // now the function to evaluate is Zp -> Zp
+    size_t p          = LUT.size();
+    uint64_t half_gap = (q + p) / (2 * p);
+    auto ct1          = std::make_shared<LWECiphertextImpl>(*ct);
+    LWEscheme->EvalAddConstEq(ct1, half_gap);  // make the error positive
+    // preprocessing for pseudo-odd and pseudo-even. NOTE: Q is not used, output modulus is 2p
+    auto fpso_pre = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        size_t x_p = (x * p / q).ConvertToInt();
+        if (x < q / 2)  // (x_p + 1/2) * 2
+            return NativeInteger(x_p * 2 + 1).Mod(2 * p);
+        else  // (-x_p + p/2 - 1/2) * 2
+            return NativeInteger((p - x_p) * 2 + p - 1).Mod(2 * p);
+    };
+    auto fpse_pre = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        size_t x_p = (x * p / q).ConvertToInt();
+        if (x < q / 2)  // (x_p + p/4 + 1/2) * 2
+            return NativeInteger(2 * x_p + p / 2 + 1).Mod(2 * p);
+        else  // (-x_p + p/4 - 1/2) * 2
+            return NativeInteger((p - x_p) * 2 + p / 2 - 1).Mod(2 * p);
+    };
+    LWECiphertext ct_pso_pre, ct_pse_pre;
+    if (use_multi_value_bts) {
+        auto rlwe_prime = PrepareRLWEPrime(params, EK, ct1, beta, 2 * p, false);  // ptxt space is 2p
+        NativeVector tv1_pso(N, 2 * p), tv1_pse(N, 2 * p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp   = NativeInteger(0).ModSub(i, dN);
+            tv1_pso[i] = fpso_pre(tmp, dN, 2 * p);
+            tv1_pse[i] = fpse_pre(tmp, dN, 2 * p);
+        }
+        // tv1_pso = tv1_pso - tv1_pso.ShiftRightNegacyclic(1);
+        // tv1_pse = tv1_pse - tv1_pse.ShiftRightNegacyclic(1);
+        tv1_pso = ComputeTV1(tv1_pso);
+        tv1_pse = ComputeTV1(tv1_pse);
+        tv1_pso.SetModulus(Q);
+        tv1_pse.SetModulus(Q);
+        NativePoly poly_pso(polyParams), poly_pse(polyParams);
+        poly_pso.SetValues(tv1_pso, Format::COEFFICIENT);
+        poly_pse.SetValues(tv1_pse, Format::COEFFICIENT);
+
+        auto acc_pso = InnerProduct(rlwe_prime, SignedDecomp(params, poly_pso, 4 * p, baseGMV)),  // ptxt space is 2p
+            acc_pse  = InnerProduct(rlwe_prime, SignedDecomp(params, poly_pse, 4 * p, baseGMV));
+        ct_pso_pre   = ExtractACC(acc_pso);
+        ct_pse_pre   = ExtractACC(acc_pse);
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(2)
+            for (size_t i = 0; i < 2; i++) {
+                if (i == 0)
+                    ct_pso_pre = BootstrapFunc(params, EK, ct1, fpso_pre, 2 * p, true);
+                else
+                    ct_pse_pre = BootstrapFunc(params, EK, ct1, fpse_pre, 2 * p, true);
+            }
+        }
+        else {
+            ct_pso_pre = BootstrapFunc(params, EK, ct1, fpso_pre, 2 * p, true);
+            ct_pse_pre = BootstrapFunc(params, EK, ct1, fpse_pre, 2 * p, true);
+        }
+    }
+    // convert back to mod p
+    LWEscheme->EvalSubConstEq(ct_pso_pre, (Q + p) / (2 * p));          // -1/2 mod p
+    LWEscheme->EvalSubConstEq(ct_pse_pre, Q / 4 + (Q + p) / (2 * p));  // -(p/4+1/2) mod p
+    // MS and KS
+    ct_pso_pre =
+        LWEscheme->ModSwitch(2 * N, LWEscheme->KeySwitch(LWEParams, EK.KSkey, LWEscheme->ModSwitch(qKS, ct_pso_pre)));
+    ct_pse_pre =
+        LWEscheme->ModSwitch(2 * N, LWEscheme->KeySwitch(LWEParams, EK.KSkey, LWEscheme->ModSwitch(qKS, ct_pse_pre)));
+    LWEscheme->EvalAddConstEq(ct_pso_pre, half_gap);
+    LWEscheme->EvalAddConstEq(ct_pse_pre, half_gap);
+    // now the pre-pso and pre-pse ctxts are ready, prepare for actual LUT.
+    // NOTE: the actual LUT is also modulo 2p
+    auto fLUT_pso = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        // (f(i) - f(p-1-i)) / 2
+        uint32_t x_p = (x * p / q).ConvertToInt();
+        if (x < q / 2)
+            return LUT[x_p].ModSubFast(LUT[p - 1 - x_p], 2 * p);
+        else
+            return LUT[p - 1 - (x_p - p / 2)].ModSubFast(LUT[x_p - p / 2], 2 * p);
+    };
+    auto fLUT_pse = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        // (f(i) + f(p-1-i)) / 2
+        uint32_t x_p = (x * p / q).ConvertToInt();
+        if (x < q / 2)
+            return LUT[x_p].ModAddFast(LUT[p - 1 - x_p], 2 * p);
+        else
+            return NativeInteger(0).ModSubFast(LUT[x_p - p / 2].ModAddFast(LUT[p - 1 - (x_p - p / 2)], 2 * p), 2 * p);
+    };
+    auto baseG_bak = RGSWParams->GetBaseG();
+    RGSWParams->Change_BaseG(baseG_small);
+    LWECiphertext ct_pso, ct_pse;
+    if (multithread) {
+#pragma omp parallel for num_threads(2)
+        for (size_t i = 0; i < 2; i++) {
+            if (i == 0)
+                ct_pso = BootstrapFunc(params, EK_small, ct_pso_pre, fLUT_pso, 2 * p, true);
+            else
+                ct_pse = BootstrapFunc(params, EK_small, ct_pse_pre, fLUT_pse, 2 * p, true);
+        }
+    }
+    else {
+        ct_pso = BootstrapFunc(params, EK_small, ct_pso_pre, fLUT_pso, 2 * p, true);
+        ct_pse = BootstrapFunc(params, EK_small, ct_pse_pre, fLUT_pse, 2 * p, true);
+    }
+    LWEscheme->EvalAddEq(ct_pso, ct_pse);
+    auto ct_res = LWEscheme->ModSwitch(q, LWEscheme->KeySwitch(LWEParams, EK.KSkey, LWEscheme->ModSwitch(qKS, ct_pso)));
+    RGSWParams->Change_BaseG(baseG_bak);
+    return ct_res;
+}
+
+// 2 pieces
+LWECiphertext BinFHEScheme::EvalFuncBFV(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                        ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                        const NativeInteger beta, double deltain, double deltaout, NativeInteger qout,
+                                        double (*f)(double m)) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto Q           = LWEParams->GetQ();
+    auto N           = LWEParams->GetN();
+    auto qKS         = LWEParams->GetqKS();
+    auto baseGMV     = RGSWparams->GetBaseGMV();
+    auto polyparams  = params->GetRingGSWParams()->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1                 = std::make_shared<LWECiphertextImpl>(*ct);
+    bool use_multi_value_bts = baseGMV > 0;
+
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        OPENFHE_THROW(openfhe_error, "CLOT21 for ckks ciphertexts is not implemented");
+    }
+
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+
+    // NOTE: we don't choose to output Q - LUT[xxx] for negative values, because tv1's can either be viewed modulo Q or modulo p
+    //  if we output p - LUT[xxx], the value of fLUT's will lie in [0,p-1]
+    //  if we output Q - LUT[xxx], the value of fLUT's will iie in [-p+1,p-1], doubling the std of noise
+    // NOTE: the third param is not used, its only usage is to fit into BootstrapFunc's API
+    auto fLUTpos = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTneg = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x >= q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTdiff = [fLUTpos, fLUTneg, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return fLUTneg(x, q, Q).ModSubFastEq(fLUTpos(x, q, Q), p);
+    };
+    auto fLUTsgn = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        // NOTE: different from fLUTsgn in EvalFuncSelect
+        if (x < q / 2)
+            return 2 * p - 1;  // modulo 2p
+        else
+            return 1;
+    };
+    // evaluate MSB*(m_neg - m_pos) + m_pos = MSB*m_diff + m_pos
+    // first obtain LWE ciphertexts
+    LWECiphertext ct_pos, ct_diff, ct_sgn;
+    if (use_multi_value_bts) {
+        auto rlwe_prime =
+            PrepareRLWEPrime(params, EK, ct1, beta, 2 * p, false);  // NOTE: ptxt space is 2p (as required by sgn)
+
+        NativeVector tv1_pos(N, 2 * p);
+        NativeVector tv1_diff(N, 2 * p);
+        NativeVector tv1_sgn(N, 2 * p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp = NativeInteger(0).ModSub(i, dN);
+            // mult by 2 to convert from Z_p to Z_2p
+            tv1_pos[i]  = 2 * fLUTpos(tmp, dN, 0);
+            tv1_diff[i] = 2 * fLUTdiff(tmp, dN, 0);
+            // fLUTsgn is already in Z_2p
+            tv1_sgn[i] = fLUTsgn(tmp, dN, 0);
+        }
+        // TODO: directly find the transition points rather than compute the difference? but the overhead here is negligible compared to blind rotation
+        tv1_pos  = ComputeTV1(tv1_pos);
+        tv1_diff = ComputeTV1(tv1_diff);
+        tv1_sgn  = ComputeTV1(tv1_sgn);
+        tv1_pos.SwitchModulus(Q);
+        tv1_diff.SwitchModulus(Q);
+        tv1_sgn.SwitchModulus(Q);
+        NativePoly poly_pos(polyparams), poly_diff(polyparams), poly_sgn(polyparams);
+        poly_pos.SetValues(tv1_pos, Format::COEFFICIENT);
+        poly_diff.SetValues(tv1_diff, Format::COEFFICIENT);
+        poly_sgn.SetValues(tv1_sgn, Format::COEFFICIENT);
+
+        auto acc_pos = InnerProduct(rlwe_prime, SignedDecomp(params, poly_pos, 4 * p,
+                                                             baseGMV)),  // NOTE: 4p here, because ptxt space is 2p
+            acc_diff = InnerProduct(rlwe_prime, SignedDecomp(params, poly_diff, 4 * p, baseGMV)),
+             acc_sgn = InnerProduct(rlwe_prime, SignedDecomp(params, poly_sgn, 4 * p, baseGMV));
+
+        // extract LWE ciphertext
+        ct_pos  = ExtractACC(acc_pos);
+        ct_diff = ExtractACC(acc_diff);
+        ct_sgn  = ExtractACC(acc_sgn);
+        LWEscheme->EvalAddConstEq(ct_sgn, (Q + p) / (2 * p));  // convert (sgn mod 2p) to (msb mod p)
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(3)
+            for (size_t i = 0; i < 3; i++) {
+                if (i == 0)
+                    ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+                else if (i == 1)
+                    ct_diff = BootstrapFunc(params, EK, ct1, fLUTdiff, p, true);
+                else
+                    ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, 2 * p, true);
+            }
+        }
+        else {
+            ct_pos  = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+            ct_diff = BootstrapFunc(params, EK, ct1, fLUTdiff, p, true);
+            ct_sgn  = BootstrapFunc(params, EK, ct1, fLUTsgn, 2 * p, true);
+        }
+        LWEscheme->EvalAddConstEq(ct_sgn, (Q + p) / (2 * p));
+    }
+
+    // use packing to convert to BFV ciphertexts
+    RLWECiphertext rlwe_diff, rlwe_sgn;
+    if (multithread) {
+#pragma omp parallel for num_threads(2)
+        for (size_t i = 0; i < 2; i++) {
+            if (i == 0)
+                rlwe_diff = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_diff, 0)});
+            else
+                rlwe_sgn = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+        }
+    }
+    else {
+        rlwe_diff = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_diff, 0)});
+        rlwe_sgn  = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+    }
+    // use BFV multiplication to select
+    // NOTE: put rlwe_sgn as ct1, and rlwe_diff as ct2 to get smaller noise growth
+    auto prod    = BFVMult(params, EK, rlwe_sgn, rlwe_diff, p);
+    auto ct_prod = ManualExtract(prod, 0);
+
+    LWEscheme->EvalAddEq(ct_prod, ct_pos);
+    // now bring the ctxt back to s,n,q
+    ct_prod = LWEscheme->ModSwitch(qKS, ct_prod);
+    ct_prod = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_prod);
+    return LWEscheme->ModSwitch(q, ct_prod);
+}
+
+// NOTE: copied from EvalFuncBFV
+LWECiphertext BinFHEScheme::EvalFuncWoPPBS2(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                            ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                            const NativeInteger beta, double deltain, double deltaout,
+                                            NativeInteger qout, double (*f)(double m)) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto Q           = LWEParams->GetQ();
+    auto N           = LWEParams->GetN();
+    auto qKS         = LWEParams->GetqKS();
+    auto baseGMV     = RGSWparams->GetBaseGMV();
+    auto polyparams  = params->GetRingGSWParams()->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1                 = std::make_shared<LWECiphertextImpl>(*ct);
+    bool use_multi_value_bts = baseGMV > 0;
+
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        OPENFHE_THROW(openfhe_error, "CLOT21 for ckks ciphertexts is not implemented");
+    }
+
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+
+    // NOTE: we don't choose to output Q - LUT[xxx] for negative values, because tv1's can either be viewed modulo Q or modulo p
+    //  if we output p - LUT[xxx], the value of fLUT's will lie in [0,p-1]
+    //  if we output Q - LUT[xxx], the value of fLUT's will iie in [-p+1,p-1], doubling the std of noise
+    // NOTE: the third param is not used, its only usage is to fit into BootstrapFunc's API
+    auto fLUTpos = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTneg = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x >= q / 2)
+            return LUT[(x * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x + q / 2) * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTsgn = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        // NOTE: different from fLUTsgn in EvalFuncSelect
+        if (x < q / 2)
+            return 2 * p - 1;  // modulo 2p
+        else
+            return 1;
+    };
+    // evaluate MSB*(m_neg - m_pos) + m_pos = MSB*m_diff + m_pos
+    // first obtain LWE ciphertexts
+    LWECiphertext ct_pos, ct_neg, ct_sgn;
+    if (use_multi_value_bts) {
+        auto rlwe_prime =
+            PrepareRLWEPrime(params, EK, ct1, beta, 2 * p, false);  // NOTE: ptxt space is 2p (as required by sgn)
+
+        NativeVector tv1_pos(N, 2 * p);
+        NativeVector tv1_neg(N, 2 * p);
+        NativeVector tv1_sgn(N, 2 * p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp = NativeInteger(0).ModSub(i, dN);
+            // mult by 2 to convert from Z_p to Z_2p
+            tv1_pos[i] = 2 * fLUTpos(tmp, dN, 0);
+            tv1_neg[i] = 2 * fLUTneg(tmp, dN, 0);
+            // fLUTsgn is already in Z_2p
+            tv1_sgn[i] = fLUTsgn(tmp, dN, 0);
+        }
+        // TODO: directly find the transition points rather than compute the difference? but the overhead here is negligible compared to blind rotation
+        tv1_pos = ComputeTV1(tv1_pos);
+        tv1_neg = ComputeTV1(tv1_neg);
+        tv1_sgn = ComputeTV1(tv1_sgn);
+        tv1_pos.SwitchModulus(Q);
+        tv1_neg.SwitchModulus(Q);
+        tv1_sgn.SwitchModulus(Q);
+        NativePoly poly_pos(polyparams), poly_neg(polyparams), poly_sgn(polyparams);
+        poly_pos.SetValues(tv1_pos, Format::COEFFICIENT);
+        poly_neg.SetValues(tv1_neg, Format::COEFFICIENT);
+        poly_sgn.SetValues(tv1_sgn, Format::COEFFICIENT);
+
+        auto acc_pos = InnerProduct(rlwe_prime, SignedDecomp(params, poly_pos, 4 * p,
+                                                             baseGMV)),  // NOTE: 4p here, because ptxt space is 2p
+            acc_neg  = InnerProduct(rlwe_prime, SignedDecomp(params, poly_neg, 4 * p, baseGMV)),
+             acc_sgn = InnerProduct(rlwe_prime, SignedDecomp(params, poly_sgn, 4 * p, baseGMV));
+
+        // extract LWE ciphertext
+        ct_pos = ExtractACC(acc_pos);
+        ct_neg = ExtractACC(acc_neg);
+        ct_sgn = ExtractACC(acc_sgn);
+        LWEscheme->EvalAddConstEq(ct_sgn, (Q + p) / (2 * p));  // convert (sgn mod 2p) to (msb mod p)
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(3)
+            for (size_t i = 0; i < 3; i++) {
+                if (i == 0)
+                    ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+                else if (i == 1)
+                    ct_neg = BootstrapFunc(params, EK, ct1, fLUTneg, p, true);
+                else
+                    ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, 2 * p, true);
+            }
+        }
+        else {
+            ct_pos = BootstrapFunc(params, EK, ct1, fLUTpos, p, true);
+            ct_neg = BootstrapFunc(params, EK, ct1, fLUTneg, p, true);
+            ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, 2 * p, true);
+        }
+        LWEscheme->EvalAddConstEq(ct_sgn, (Q + p) / (2 * p));
+    }
+
+    // use packing to convert to BFV ciphertexts
+    RLWECiphertext rlwe_pos, rlwe_neg, rlwe_sgn;
+    if (multithread) {
+#pragma omp parallel for num_threads(3)
+        for (size_t i = 0; i < 3; i++) {
+            if (i == 0)
+                rlwe_pos = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_pos, 0)});
+            else if (i == 1)
+                rlwe_neg = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_neg, 0)});
+            else
+                rlwe_sgn = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+        }
+    }
+    else {
+        rlwe_pos = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_pos, 0)});
+        rlwe_neg = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_neg, 0)});
+        rlwe_sgn = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+    }
+    // use BFV multiplication to select
+    // NOTE: put rlwe_sgn as ct1, and rlwe_diff as ct2 to get smaller noise growth
+    auto prod = BFVMult(params, EK, rlwe_sgn, rlwe_neg, p);
+    // obtain (Q/p - MSB) and mult with rlwe_pos
+    rlwe_sgn->GetElements()[0] = -rlwe_sgn->GetElements()[0];
+    rlwe_sgn->GetElements()[1] = -rlwe_sgn->GetElements()[1];
+    rlwe_sgn->GetElements()[1][0].ModAddFastEq((Q + p / 2) / p, Q);
+    auto prod_pos = BFVMult(params, EK, rlwe_sgn, rlwe_pos, p);
+    auto ct_prod  = ManualExtract(prod, 0);
+    LWEscheme->EvalAddEq(ct_prod, ManualExtract(prod_pos, 0));
+    // now bring the ctxt back to s,n,q
+    ct_prod = LWEscheme->ModSwitch(qKS, ct_prod);
+    ct_prod = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_prod);
+    return LWEscheme->ModSwitch(q, ct_prod);
+}
+
+// NOTE: copied from EvalFuncBFV
+LWECiphertext BinFHEScheme::EvalFuncWoPPBS1(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                            ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                            const NativeInteger beta, double deltain, double deltaout,
+                                            NativeInteger qout, double (*f)(double m)) const {
+    auto LWEParams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto Q           = LWEParams->GetQ();
+    auto N           = LWEParams->GetN();
+    auto qKS         = LWEParams->GetqKS();
+    auto baseGMV     = RGSWparams->GetBaseGMV();
+    auto polyparams  = params->GetRingGSWParams()->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    auto ct1                 = std::make_shared<LWECiphertextImpl>(*ct);
+    bool use_multi_value_bts = baseGMV > 0;
+
+    NativeInteger q = ct->GetModulus();
+    if (f != nullptr) {
+        OPENFHE_THROW(openfhe_error, "CLOT21 for ckks ciphertexts is not implemented");
+    }
+
+    // now the function to evaluate is a Z_p to Z_p mapping
+    usint p = LUT.size();
+    if (p & 1) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p must be even");
+    }
+    usint half_gap = (q.ConvertToInt() + p) / (2 * p);
+    if (half_gap <= beta) {
+        OPENFHE_THROW(openfhe_error, "plaintext modulus p too large");
+    }
+
+    LWEscheme->EvalAddConstEq(ct1, half_gap);
+    auto dq = q << 1;
+    ct1->SetModulus(dq);
+
+    // NOTE: the third param is not used, its only usage is to fit into BootstrapFunc's API
+    auto fLUT = [LUT, p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return LUT[(x * 2 * p / q).ConvertToInt()];
+        else
+            return (p - LUT[((x - q / 2) * 2 * p / q).ConvertToInt()]).Mod(p);
+    };
+    auto fLUTsgn = [p](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return 1;  // modulo p
+        else
+            return p - 1;
+    };
+    // first obtain LWE ciphertexts
+    LWECiphertext ct_lut, ct_sgn;
+    if (use_multi_value_bts) {
+        auto rlwe_prime =
+            PrepareRLWEPrime(params, EK, ct1, beta, p, false);  // NOTE: ptxt space is 2p (as required by sgn)
+
+        NativeVector tv1_lut(N, p);
+        NativeVector tv1_sgn(N, p);
+        for (size_t i = 0, dN = 2 * N; i < N; i++) {
+            auto tmp   = NativeInteger(0).ModSub(i, dN);
+            tv1_lut[i] = fLUT(tmp, dN, 0);
+            tv1_sgn[i] = fLUTsgn(tmp, dN, 0);
+        }
+        // TODO: directly find the transition points rather than compute the difference? but the overhead here is negligible compared to blind rotation
+        tv1_lut = ComputeTV1(tv1_lut);
+        tv1_sgn = ComputeTV1(tv1_sgn);
+        tv1_lut.SwitchModulus(Q);
+        tv1_sgn.SwitchModulus(Q);
+        NativePoly poly_lut(polyparams), poly_sgn(polyparams);
+        poly_lut.SetValues(tv1_lut, Format::COEFFICIENT);
+        poly_sgn.SetValues(tv1_sgn, Format::COEFFICIENT);
+
+        auto acc_lut = InnerProduct(rlwe_prime, SignedDecomp(params, poly_lut, 2 * p, baseGMV)),
+             acc_sgn = InnerProduct(rlwe_prime, SignedDecomp(params, poly_sgn, 2 * p, baseGMV));
+
+        // extract LWE ciphertext
+        ct_lut = ExtractACC(acc_lut);
+        ct_sgn = ExtractACC(acc_sgn);
+    }
+    else {
+        if (multithread) {
+#pragma omp parallel for num_threads(2)
+            for (size_t i = 0; i < 2; i++) {
+                if (i == 0)
+                    ct_lut = BootstrapFunc(params, EK, ct1, fLUT, p, true);
+                else
+                    ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, p, true);
+            }
+        }
+        else {
+            ct_lut = BootstrapFunc(params, EK, ct1, fLUT, p, true);
+            ct_sgn = BootstrapFunc(params, EK, ct1, fLUTsgn, p, true);
+        }
+    }
+
+    // use packing to convert to BFV ciphertexts
+    RLWECiphertext rlwe_lut, rlwe_sgn;
+    if (multithread) {
+#pragma omp parallel for num_threads(2)
+        for (size_t i = 0; i < 2; i++) {
+            if (i == 0)
+                rlwe_lut = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_lut, 0)});
+            else
+                rlwe_sgn = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+        }
+    }
+    else {
+        rlwe_lut = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_lut, 0)});
+        rlwe_sgn = FunctionalKeySwitch(params, EK.PKkey_const, 1, {std::make_pair(ct_sgn, 0)});
+    }
+    // use BFV multiplication to select
+    // NOTE: put rlwe_sgn as ct1, and rlwe_diff as ct2 to get smaller noise growth
+    auto prod    = BFVMult(params, EK, rlwe_sgn, rlwe_lut, p);
+    auto ct_prod = ManualExtract(prod, 0);
+    // now bring the ctxt back to s,n,q
+    ct_prod = LWEscheme->ModSwitch(qKS, ct_prod);
+    ct_prod = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ct_prod);
+    return LWEscheme->ModSwitch(q, ct_prod);
+}
+
+LWECiphertext BinFHEScheme::EvalReLU(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK_sgn,
+                                     uint32_t baseG_sgn, const RingGSWBTKey& EK_sel, uint32_t baseG_sel,
+                                     ConstLWECiphertext ct, ConstLWECiphertext ct_msd, size_t beta) const {
+    auto LWEparams  = params->GetLWEParams();
+    auto RGSWparams = params->GetRingGSWParams();
+    auto N          = LWEparams->GetN();
+
+    auto baseG_bak = RGSWparams->GetBaseG();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct_msd);
+    LWEscheme->EvalAddConstEq(ct1, beta);  // add half_gap to make error positive
+    auto fLUTsgn = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return Q / 8;
+        else
+            return Q - Q / 8;
+    };
+    RGSWparams->Change_BaseG(baseG_sgn);
+    auto ct_sgn = BootstrapFunc(params, EK_sgn, ct1, fLUTsgn, 2 * N);
+    // NOTE: use trans PKkey here
+    auto packed = FunctionalKeySwitch(params, EK_sgn.PKKey_half_trans, N / 2, {std::make_pair(ct, 3 * N / 2 + 1)});
+    RGSWparams->Change_BaseG(baseG_sel);
+    auto ct_res = BootstrapCtxt(params, EK_sel, ct_sgn, packed, 0, false, false);  // return modulus in q_ks
+
+    RGSWparams->Change_BaseG(baseG_bak);
+    return ct_res;
+}
+
+// Evaluate Homomorphic Flooring
+LWECiphertext BinFHEScheme::EvalFloor(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                      ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits) const {
+    auto& LWEParams   = params->GetLWEParams();
+    NativeInteger q   = roundbits == 0 ? LWEParams->Getq() : beta * 2 * (1 << roundbits);
+    NativeInteger mod = ct->GetModulus();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    LWEscheme->EvalAddConstEq(ct1, beta);
+
+    auto ct1Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct1Modq->SetModulus(q);
+    // this is 1/4q_small or -1/4q_small mod q
+    auto f1 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return Q - q / 4;
+        else
+            return q / 4;
+    };
+    auto ct2 = BootstrapFunc(params, EK, ct1Modq, f1, mod);
+    LWEscheme->EvalSubEq(ct1, ct2);
+
+    auto ct2Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct2Modq->SetModulus(q);
+
+    // now the input is only within the range [0, q/2)
+    auto f2 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 4)
+            return Q - q / 2 - x;
+        else if ((q / 4 <= x) && (x < 3 * q / 4))
+            return x;
+        else
+            return Q + q / 2 - x;
+    };
+    auto ct3 = BootstrapFunc(params, EK, ct2Modq, f2, mod);
+    LWEscheme->EvalSubEq(ct1, ct3);
+
+    return ct1;
+}
+
+// Evaluate large-precision sign
+LWECiphertext BinFHEScheme::EvalSign(const std::shared_ptr<BinFHECryptoParams> params,
+                                     const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                     const NativeInteger beta) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    while (mod > q) {
+        cttmp = EvalFloor(params, curEK, cttmp, beta);
+        mod   = mod / q * 2 * beta;
+        // round Q to 2betaQ/q
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog <= static_cast<uint32_t>(17))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog <= static_cast<uint32_t>(26))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // if the ended q is smaller than q, we need to change the param for the final boostrapping
+    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    };
+    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    return cttmp;
+}
+
+// Evaluate Ciphertext Decomposition
+std::vector<LWECiphertext> BinFHEScheme::EvalDecomp(const std::shared_ptr<BinFHECryptoParams> params,
+                                                    const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                                    const NativeInteger beta, bool CKKS) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    std::vector<LWECiphertext> ret;
+    while (mod > q) {
+        auto ctq = std::make_shared<LWECiphertextImpl>(*cttmp);
+        ctq->SetModulus(q);
+        ret.push_back(std::move(ctq));
+
+        // Floor the input sequentially to obtain the most significant bit
+        if (CKKS) {  // CKKS only affects the 1st iteration
+            cttmp = EvalFloor(params, curEK, cttmp, 0);
+            CKKS  = false;
+        }
+        else
+            cttmp = EvalFloor(params, curEK, cttmp, beta);
+        mod = mod / q * 2 * beta;
+        // round Q to 2betaQ/q
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog < static_cast<uint32_t>(17))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog < static_cast<uint32_t>(26))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    // LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // FIXME: what are they doing here? this is decomp, not sign
+    // auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //     return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    // };
+    // cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    // LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    ret.push_back(std::move(cttmp));
+    return ret;
+}
+
+// alt
+// Evaluate Homomorphic Flooring
+// NOTE: EvalFloorAlt assumes the input ctxt in CKKS-style
+LWECiphertext BinFHEScheme::EvalFloorAlt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                         ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits) const {
+    auto& LWEParams   = params->GetLWEParams();
+    NativeInteger q   = roundbits == 0 ? LWEParams->Getq() : beta * 2 * (1 << roundbits);
+    NativeInteger mod = ct->GetModulus();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    LWEscheme->EvalAddConstEq(ct1, beta);  // NOTE: always add beta
+
+    auto ct1Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct1Modq->SetModulus(q);
+    // this is 1/4q_small or -1/4q_small mod q
+    auto fx = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 4)
+            return Q - q / 4;
+        else if (q / 2 <= x && x < q * 3 / 4)
+            return q / 4;
+        else
+            return 0;
+    };
+    auto ct2 = BootstrapFunc(params, EK, ct1Modq, fx, mod);
+    LWEscheme->EvalSubEq(ct1, ct2);
+    LWEscheme->EvalSubConstEq(ct1, q / 8);
+
+    auto ct2Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct2Modq->SetModulus(q);
+
+    // now the input is in [q/8,3q/8) U [5q/8,7q/8)
+    auto f0 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return Q - q / 4;
+        else
+            return q / 4;
+    };
+    auto ct3 = BootstrapFunc(params, EK, ct2Modq, f0, mod);
+    LWEscheme->EvalSubEq(ct1, ct3);
+
+    auto ct3Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct3Modq->SetModulus(q);
+
+    // now the input is only within the range [3/8q, 5q/8)
+    auto f2 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 4)
+            return Q - q / 2 - x;
+        else if ((q / 4 <= x) && (x < 3 * q / 4))
+            return x;
+        else
+            return Q + q / 2 - x;
+    };
+    auto ct4 = BootstrapFunc(params, EK, ct3Modq, f2, mod);
+    LWEscheme->EvalSubEq(ct1, ct4);
+
+    return ct1;
+}
+
+// Evaluate large-precision sign
+LWECiphertext BinFHEScheme::EvalSignAlt(const std::shared_ptr<BinFHECryptoParams> params,
+                                        const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                        const NativeInteger beta, bool fast, bool CKKS) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    // add initial beta to ct iff CKKS is false
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    if (!CKKS)
+        LWEscheme->EvalAddConstEq(cttmp, beta);
+    bool first_iter = true;
+    while (mod > q) {
+        if (first_iter)  // first iter always operates on CKKS-like ctxt
+            cttmp = EvalFloorAlt(params, curEK, cttmp, beta);
+        else if (!fast) {
+            LWEscheme->EvalAddConstEq(cttmp, beta / 2);  // alpha = 2^7 = beta
+            cttmp = EvalFloorAlt(params, curEK, cttmp, beta);
+        }
+        else {                                       // fast
+            LWEscheme->EvalAddConstEq(cttmp, beta);  // alpha = 2^8 = 2 beta
+            cttmp = EvalFloor(params, curEK, cttmp, beta);
+        }
+        // if fast is true, we cannot reduce 5 bits at first iter, otherwise the noise will be too large for HomFloor. so we reduce 4 bits per iter
+        if (fast)
+            mod = mod / q * 2 * beta;  // 4 bits per iter
+        else
+            mod = mod / q * beta;  // 5 bits per iter
+        // round Q to mod
+        cttmp      = LWEscheme->ModSwitch(mod, cttmp);
+        first_iter = false;
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog <= static_cast<uint32_t>(17))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog <= static_cast<uint32_t>(26))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    if (fast)
+        LWEscheme->EvalAddConstEq(cttmp, beta);
+    else
+        LWEscheme->EvalAddConstEq(cttmp, beta / 2);
+
+    // if the ended q is smaller than q, we need to change the param for the final boostrapping
+    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    };
+    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    return cttmp;
+}
+
+// Evaluate Ciphertext Decomposition
+std::vector<LWECiphertext> BinFHEScheme::EvalDecompAlt(const std::shared_ptr<BinFHECryptoParams> params,
+                                                       const std::map<uint32_t, RingGSWBTKey>& EKs,
+                                                       ConstLWECiphertext ct, const NativeInteger beta,
+                                                       bool CKKS) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    std::vector<LWECiphertext> ret;
+    while (mod > q) {
+        auto ctq = std::make_shared<LWECiphertextImpl>(*cttmp);
+        ctq->SetModulus(q);
+        ret.push_back(std::move(ctq));
+
+        // Floor the input sequentially to obtain the most significant bit
+        if (CKKS) {
+            cttmp = EvalFloorAlt(params, curEK, cttmp, 0);
+            CKKS  = false;
+        }
+        else
+            cttmp = EvalFloorAlt(params, curEK, cttmp, beta);
+        mod = mod / 32;  // 5 bits per iter
+        // round Q to mod
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog < static_cast<uint32_t>(20))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog < static_cast<uint32_t>(28))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    // LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //     return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    // };
+    // cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    // LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    ret.push_back(std::move(cttmp));
+    return ret;
+}
+
+// new
+
+// Evaluate Homomorphic Flooring
+LWECiphertext BinFHEScheme::EvalFloorNew(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                         ConstLWECiphertext ct, const NativeInteger beta, uint32_t roundbits) const {
+    auto& LWEParams   = params->GetLWEParams();
+    NativeInteger q   = roundbits == 0 ? LWEParams->Getq() : beta * 2 * (1 << roundbits);
+    NativeInteger mod = ct->GetModulus();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    LWEscheme->EvalAddConstEq(ct1, beta);
+
+    auto ct1Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct1Modq->SetModulus(q);
+    // this is 1/4q_small or -1/4q_small mod q
+    auto f1 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return Q - q / 4;
+        else
+            return q / 4;
+    };
+    auto ct2 = BootstrapFunc(params, EK, ct1Modq, f1, mod);
+    LWEscheme->EvalSubEq(ct1, ct2);
+    // now the lower q of ct1 is centered at q/2 with error = e_bt
+    // re-center at 0 by subtracting q/2
+    LWEscheme->EvalSubConstEq(ct1, q / 2);
+    // old noise <= bound(e_bt) = 128
+    // new noise <= q/4 + bound(e_bt) = 1024+128 < 2048 = q/2
+
+    // auto ct2Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    // ct2Modq->SetModulus(q);
+
+    // // now the input is only within the range [0, q/2)
+    // auto f2 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //     if (x < q / 4)
+    //         return Q - q / 2 - x;
+    //     else if ((q / 4 <= x) && (x < 3 * q / 4))
+    //         return x;
+    //     else
+    //         return Q + q / 2 - x;
+    // };
+    // auto ct3 = BootstrapFunc(params, EK, ct2Modq, f2, mod);
+    // LWEscheme->EvalSubEq(ct1, ct3);
+
+    return ct1;
+}
+
+// Evaluate large-precision sign
+LWECiphertext BinFHEScheme::EvalSignNew(const std::shared_ptr<BinFHECryptoParams> params,
+                                        const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                        const NativeInteger beta) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    while (mod > q) {
+        cttmp = EvalFloorNew(params, curEK, cttmp, beta);
+        mod   = mod / q * 2 * beta;
+        // round Q to 2betaQ/q
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+        // old noise = 2^-4 * e_bt + e_ms, bound = 54.46
+        // new noise = 2^-4 * e_bt + e_ms + 2^-4 * q/4, bound = 64 + 54.46 < 128 = beta
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog <= static_cast<uint32_t>(20))
+                base = static_cast<uint32_t>(1) << 27;
+            else
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // if the ended q is smaller than q, we need to change the param for the final boostrapping
+    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    };
+    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    return cttmp;
+}
+
+// Evaluate Ciphertext Decomposition
+std::vector<LWECiphertext> BinFHEScheme::EvalDecompNew(const std::shared_ptr<BinFHECryptoParams> params,
+                                                       const std::map<uint32_t, RingGSWBTKey>& EKs,
+                                                       ConstLWECiphertext ct, const NativeInteger beta,
+                                                       bool CKKS) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    std::vector<LWECiphertext> ret;
+    while (mod > q) {
+        auto ctq = std::make_shared<LWECiphertextImpl>(*cttmp);
+        ctq->SetModulus(q);
+        ret.push_back(std::move(ctq));
+
+        // Floor the input sequentially to obtain the most significant bit
+        if (CKKS) {
+            cttmp = EvalFloorNew(params, curEK, cttmp, 0);
+            CKKS  = false;
+        }
+        else
+            cttmp = EvalFloorNew(params, curEK, cttmp, beta);
+        mod   = mod / 16;  // 4 bits
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog < static_cast<uint32_t>(20))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog < static_cast<uint32_t>(29))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    // LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+    //     return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    // };
+    // cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    // LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    ret.push_back(std::move(cttmp));
+    return ret;
+}
+LWECiphertext BinFHEScheme::EvalFloorCompress(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                              ConstLWECiphertext ct, const NativeInteger beta,
+                                              const NativeInteger precise_beta, uint32_t roundbits) const {
+    auto& LWEParams   = params->GetLWEParams();
+    NativeInteger q   = roundbits == 0 ? LWEParams->Getq() : beta * 2 * (1 << roundbits);
+    NativeInteger mod = ct->GetModulus();
+
+    auto ct1 = std::make_shared<LWECiphertextImpl>(*ct);
+    LWEscheme->EvalAddConstEq(ct1, beta);
+
+    auto ct1Modq = std::make_shared<LWECiphertextImpl>(*ct1);
+    ct1Modq->SetModulus(q);
+    // use COMPRESS to remove the lower bits
+    double (*f_id)(double) = [](double x) -> double {
+        return x;
+    };
+    auto ct2 =
+        EvalFuncCompress(params, EK, ct1Modq, {}, precise_beta, 1, 1, mod, f_id, false);  // interpret input as unsigned
+    LWEscheme->EvalSubEq(ct1, ct2);
+    // now the lower bits are cleared
+    return ct1;
+}
+LWECiphertext BinFHEScheme::EvalSignCompress(const std::shared_ptr<BinFHECryptoParams> params,
+                                             const std::map<uint32_t, RingGSWBTKey>& EKs, ConstLWECiphertext ct,
+                                             const NativeInteger beta, const NativeInteger precise_beta) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    while (mod > q) {
+        cttmp = EvalFloorCompress(params, curEK, cttmp, beta, precise_beta);
+        mod   = mod / 32;  // 5 bits
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        // faster
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog <= static_cast<uint32_t>(21))
+                base = static_cast<uint32_t>(1) << 27;
+            else
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    LWEscheme->EvalAddConstEq(cttmp, beta);
+
+    // if the ended q is smaller than q, we need to change the param for the final boostrapping
+    auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        return (x < q / 2) ? (Q / 4) : (Q - Q / 4);
+    };
+    cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q
+    RGSWParams->Change_BaseG(curBase);
+    LWEscheme->EvalSubConstEq(cttmp, q >> 2);
+    return cttmp;
+}
+std::vector<LWECiphertext> BinFHEScheme::EvalDecompCompress(const std::shared_ptr<BinFHECryptoParams> params,
+                                                            const std::map<uint32_t, RingGSWBTKey>& EKs,
+                                                            ConstLWECiphertext ct, const NativeInteger beta,
+                                                            const NativeInteger precise_beta, bool CKKS) const {
+    auto mod         = ct->GetModulus();
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+
+    NativeInteger q = LWEParams->Getq();
+    if (mod <= q) {
+        std::string errMsg =
+            "ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly";
+        OPENFHE_THROW(not_implemented_error, errMsg);
+    }
+
+    const auto curBase = RGSWParams->GetBaseG();
+    auto search        = EKs.find(curBase);
+    if (search == EKs.end()) {
+        std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+        OPENFHE_THROW(openfhe_error, errMsg);
+    }
+    RingGSWBTKey curEK(search->second);
+
+    auto cttmp = std::make_shared<LWECiphertextImpl>(*ct);
+    std::vector<LWECiphertext> ret;
+    while (mod > q) {
+        auto ctq = std::make_shared<LWECiphertextImpl>(*cttmp);
+        ctq->SetModulus(q);
+        ret.push_back(std::move(ctq));
+
+        // Floor the input sequentially to obtain the most significant bit
+        if (CKKS) {
+            cttmp = EvalFloorCompress(params, curEK, cttmp, 0, precise_beta);
+            CKKS  = false;
+        }
+        else
+            cttmp = EvalFloorCompress(params, curEK, cttmp, beta, precise_beta);
+        mod   = mod / 32;  // 5 bits
+        cttmp = LWEscheme->ModSwitch(mod, cttmp);
+
+        if (EKs.size() > 1) {  // if dynamic
+            uint32_t binLog = static_cast<uint32_t>(ceil(log2(mod.ConvertToInt())));
+            uint32_t base   = 0;
+            if (binLog < static_cast<uint32_t>(21))
+                base = static_cast<uint32_t>(1) << 27;
+            else if (binLog < static_cast<uint32_t>(30))
+                base = static_cast<uint32_t>(1) << 18;
+
+            if (0 != base) {  // if base is to change ...
+                RGSWParams->Change_BaseG(base);
+
+                auto search = EKs.find(base);
+                if (search == EKs.end()) {
+                    std::string errMsg("ERROR: No key [" + std::to_string(curBase) + "] found in the map");
+                    OPENFHE_THROW(openfhe_error, errMsg);
+                }
+                curEK = search->second;
+            }
+        }
+    }
+    RGSWParams->Change_BaseG(curBase);
+    ret.push_back(std::move(cttmp));
+    return ret;
+}
+// private:
+
+RLWECiphertext BinFHEScheme::BootstrapGateCore(const std::shared_ptr<BinFHECryptoParams> params, BINGATE gate,
+                                               const RingGSWACCKey ek, ConstLWECiphertext ct) const {
+    if (ek == nullptr) {
+        std::string errMsg =
+            "Bootstrapping keys have not been generated. Please call BTKeyGen "
+            "before calling bootstrapping.";
+        OPENFHE_THROW(config_error, errMsg);
+    }
+
+    auto& LWEParams  = params->GetLWEParams();
     auto& RGSWParams = params->GetRingGSWParams();
     auto polyParams  = RGSWParams->GetPolyParams();
 
@@ -501,6 +2986,8 @@ RLWECiphertext BinFHEScheme::BootstrapGateCore(const std::shared_ptr<BinFHECrypt
 template <typename Func>
 RLWECiphertext BinFHEScheme::BootstrapFuncCore(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWACCKey ek,
                                                ConstLWECiphertext ct, const Func f, const NativeInteger fmod) const {
+    // auto t_start = std::chrono::steady_clock::now();
+
     if (ek == nullptr) {
         std::string errMsg =
             "Bootstrapping keys have not been generated. Please call BTKeyGen before calling bootstrapping.";
@@ -534,13 +3021,17 @@ RLWECiphertext BinFHEScheme::BootstrapFuncCore(const std::shared_ptr<BinFHECrypt
     // evaluation
     auto acc = std::make_shared<RLWECiphertextImpl>(std::move(res));
     ACCscheme->EvalAcc(RGSWParams, ek, acc, ct->GetA());
+
+    // auto t_end = std::chrono::steady_clock::now();
+    // std::cout << "time for btsFuncCore: " << (t_end - t_start).count() << " ns\n";
     return acc;
 }
 
 // Full evaluation as described in https://eprint.iacr.org/2020/086
 template <typename Func>
 LWECiphertext BinFHEScheme::BootstrapFunc(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
-                                          ConstLWECiphertext ct, const Func f, const NativeInteger fmod) const {
+                                          ConstLWECiphertext ct, const Func f, const NativeInteger fmod, bool raw,
+                                          bool ms) const {
     auto acc = BootstrapFuncCore(params, EK.BSkey, ct, f, fmod);
 
     std::vector<NativePoly>& accVec = acc->GetElements();
@@ -550,14 +3041,909 @@ LWECiphertext BinFHEScheme::BootstrapFunc(const std::shared_ptr<BinFHECryptoPara
     accVec[0].SetFormat(Format::COEFFICIENT);
     accVec[1].SetFormat(Format::COEFFICIENT);
 
-    auto ctExt      = std::make_shared<LWECiphertextImpl>(std::move(accVec[0].GetValues()), std::move(accVec[1][0]));
+    auto ctExt = std::make_shared<LWECiphertextImpl>(std::move(accVec[0].GetValues()), std::move(accVec[1][0]));
+    if (raw)
+        return ctExt;
+
+    auto& LWEParams = params->GetLWEParams();
+    // Modulus switching to a middle step Q'
+    auto ctMS = LWEscheme->ModSwitch(LWEParams->GetqKS(), ctExt);
+    // Key switching
+    auto ctKS = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ctMS);
+    if (!ms)
+        return ctKS;
+    // Modulus switching
+    return LWEscheme->ModSwitch(fmod, ctKS);
+}
+
+RLWECiphertext BinFHEScheme::BootstrapCtxtCore(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWACCKey ek,
+                                               ConstLWECiphertext ct, ConstRLWECiphertext tv) const {
+    // auto t_start = std::chrono::steady_clock::now();
+    if (ek == nullptr) {
+        std::string errMsg =
+            "Bootstrapping keys have not been generated. Please call BTKeyGen before calling bootstrapping.";
+        OPENFHE_THROW(config_error, errMsg);
+    }
+
+    auto& LWEParams  = params->GetLWEParams();
+    auto& RGSWParams = params->GetRingGSWParams();
+    auto polyParams  = RGSWParams->GetPolyParams();
+
+    NativeInteger Q = LWEParams->GetQ();
+    uint32_t N      = LWEParams->GetN();
+    NativeVector m(N, Q);
+
+    auto acc = std::make_shared<RLWECiphertextImpl>(*tv);
+    auto b   = ct->GetB().ConvertToInt();
+    for (auto& ele : acc->GetElements()) {
+        // EvalAcc evaluates Tv*X^(b-as)=Tv*X^m
+        ele.SetFormat(Format::COEFFICIENT);
+        ele = ele.ShiftRightNegacyclic(b);
+        ele.SetFormat(Format::EVALUATION);
+    }
+    // main accumulation computation
+    // the following loop is the bottleneck of bootstrapping/binary gate
+    // evaluation
+    ACCscheme->EvalAcc(RGSWParams, ek, acc, ct->GetA());
+
+    // auto t_end = std::chrono::steady_clock::now();
+    // std::cout << "time for btsCtxtCore: " << (t_end - t_start).count() << " ns\n";
+    return acc;
+}
+
+// bootstrap a ctxt test vector
+LWECiphertext BinFHEScheme::BootstrapCtxt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                          ConstLWECiphertext ct, ConstRLWECiphertext tv, const NativeInteger fmod,
+                                          bool raw, bool ms) const {
+    auto acc = BootstrapCtxtCore(params, EK.BSkey, ct, tv);
+
+    std::vector<NativePoly>& accVec = acc->GetElements();
+    // the accumulator result is encrypted w.r.t. the transposed secret key
+    // we can transpose "a" to get an encryption under the original secret key
+    accVec[0] = accVec[0].Transpose();
+    accVec[0].SetFormat(Format::COEFFICIENT);
+    accVec[1].SetFormat(Format::COEFFICIENT);
+
+    auto ctExt = std::make_shared<LWECiphertextImpl>(std::move(accVec[0].GetValues()), std::move(accVec[1][0]));
+    if (raw)
+        return ctExt;
     auto& LWEParams = params->GetLWEParams();
     // Modulus switching to a middle step Q'
     auto ctMS = LWEscheme->ModSwitch(LWEParams->GetqKS(), ctExt);
     // Key switching
     auto ctKS = LWEscheme->KeySwitch(LWEParams, EK.KSkey, ctMS);
+    if (!ms)
+        return ctKS;
     // Modulus switching
     return LWEscheme->ModSwitch(fmod, ctKS);
 }
 
+// we don't need NTT structure here, so we view polys as vecs to avoid possible troubles
+NativeVector BinFHEScheme::ModSwitch(NativeInteger q, const NativeVector& polyQ) const {
+    auto length  = polyQ.GetLength();
+    double ratio = q.ConvertToDouble() / polyQ.GetModulus().ConvertToDouble();
+    NativeVector polyq(length, q);
+    for (usint i = 0; i < length; i++) {
+        polyq[i] = NativeInteger(static_cast<uint64_t>(std::floor(0.5 + polyQ[i].ConvertToDouble() * ratio))).Mod(q);
+    }
+    return polyq;
+}
+
+// we don't need NTT structure here, so we view polys as vecs to avoid possible troubles
+void BinFHEScheme::ModSwitchInplace(NativeInteger q, NativeVector& polyQ) const {
+    auto length  = polyQ.GetLength();
+    double ratio = q.ConvertToDouble() / polyQ.GetModulus().ConvertToDouble();
+    for (usint i = 0; i < length; i++) {
+        polyQ[i] = NativeInteger(static_cast<uint64_t>(std::floor(0.5 + polyQ[i].ConvertToDouble() * ratio))).Mod(q);
+    }
+    polyQ.SetModulus(q);
+}
+
+RLWECiphertext BinFHEScheme::vecs_to_RLWECiphertext(std::vector<NativeVector>&& vectors,
+                                                    const std::shared_ptr<ILNativeParams> params) const {
+    std::vector<NativePoly> polys;
+    for (auto&& ele : vectors) {
+        NativePoly tmp(params);
+        tmp.SetValues(std::move(ele), Format::COEFFICIENT);
+        polys.emplace_back(std::move(tmp));
+    }
+    return std::make_shared<RLWECiphertextImpl>(polys);
+}
+
+// here we need LWE(q,N) to RLWE(Q,N) key switching, where q | 2N is very small
+// generate RLWE(round(Q/qfrom * svN[i]*j*basePK^k)*(1+X+...+X^(nOnes-1))), accessed as (A[i][j][k], B[i][j][k])
+RLWESwitchingKey BinFHEScheme::FunctionalKeySwitchGen(const std::shared_ptr<BinFHECryptoParams> params,
+                                                      ConstLWEPrivateKey sk, const NativePoly& skNTT,
+                                                      usint nOnes) const {
+    // Create local copies of main variables
+    auto LWEparams  = params->GetLWEParams();
+    auto RGSWparams = params->GetRingGSWParams();
+    // uint32_t n          = LWEparams->Getn();
+    uint32_t dim_in     = sk->GetLength();
+    uint32_t N          = LWEparams->GetN();
+    NativeInteger qPK   = LWEparams->GetQ();
+    uint32_t basePK     = RGSWparams->GetBasePK();
+    NativeInteger qfrom = RGSWparams->GetQfrom();
+    auto polyparams     = RGSWparams->GetPolyParams();
+
+    // Number of digits in representing numbers mod 2N
+    uint32_t digitCount = (uint32_t)std::ceil(log(qfrom.ConvertToDouble()) / log(static_cast<double>(basePK)));
+    std::vector<NativeInteger> digitsKS;
+    // Populate digits
+    NativeInteger value = 1;
+    for (size_t i = 0; i < digitCount; ++i) {
+        digitsKS.push_back(value);
+        value *= basePK;
+    }
+
+    NativeVector sv = sk->GetElement();
+    sv.SwitchModulus(qPK);
+
+    DiscreteUniformGeneratorImpl<NativeVector> dug;
+    dug.SetModulus(qPK);
+
+    // auto mu = qPK.ComputeMu();
+
+    std::vector<std::vector<std::vector<NativeVector>>> resultVecA(dim_in);
+    std::vector<std::vector<std::vector<NativeVector>>> resultVecB(dim_in);
+
+    std::cout << "i j k = " << dim_in << ", " << basePK << ", " << digitCount << '\n';
+
+#pragma omp parallel for
+    for (size_t i = 0; i < dim_in; ++i) {
+        std::vector<std::vector<NativeVector>> vector1A(basePK);
+        std::vector<std::vector<NativeVector>> vector1B(basePK);
+        for (size_t j = 1; j < basePK; ++j) {  // NOTE: skip j = 0
+            std::vector<NativeVector> vector2A(digitCount);
+            std::vector<NativeVector> vector2B(digitCount);
+            for (size_t k = 0; k < digitCount; ++k) {
+                // NOTE: if we generate RLWE encryptions modulo Q, then rescale them down to q_ks, the rescaling error is far larger than encryption error
+                // so we have to generate RLWE encryptions modulo q_ks, which requires polynomial multiplication under non-NTT-friendly modulus
+                NativePoly apoly(dug, polyparams, Format::COEFFICIENT);
+                // NativeVector as = PolyMult(a, svN);
+                // NativeVector as = FromZZpX(NTL::MulMod(ToZZpX(a), skN_ZZp, xn_1));
+                NativePoly as(polyparams, Format::COEFFICIENT);
+                as.SetValues(apoly.GetValues(), Format::COEFFICIENT);
+                as.SetFormat(Format::EVALUATION);
+                as *= skNTT;
+                as.SetFormat(Format::COEFFICIENT);
+
+                NativeVector b = RGSWparams->GetDgg().GenerateVector(N, qPK);
+                b.ModAddEq(as.GetValues());
+
+                NativeVector a = apoly.GetValues();
+
+                // ModSwitchInplace(qPK, a);
+                // ModSwitchInplace(qPK, b);
+
+                // message is sv[i] * j * B^k * (1+X+X^2+...+X^(nOnes-1)) * qKS / qfrom
+                // NOTE: need to convert sv[i] to signed form before converting to double
+                //   static_cast a negative double to unsigned integer type is UB!
+                //   the implementation of ModMul uses 128 bit integer to hold the product (or Barret reduction when 128-bit integer is not available)
+                //   we assume 128-bit integers are available
+                auto qPK_128      = static_cast<uint128_t>(qPK.ConvertToInt()),
+                     qfrom_128    = static_cast<uint128_t>(qfrom.ConvertToInt());
+                uint128_t svi_128 = static_cast<uint128_t>(sv[i].ConvertToInt());
+                if (svi_128 != 0 && svi_128 != 1)
+                    svi_128 = static_cast<uint128_t>(-1);
+                // uint64_t msg = (svi_128 * static_cast<uint128_t>(j) *
+                //                     static_cast<uint128_t>(digitsKS[k].ConvertToInt()) * qPK_128 +
+                //                 qfrom_128 / 2) /
+                //                qfrom_128;
+
+                uint64_t d_msg;
+                if (svi_128 == 0)
+                    d_msg = 0;
+                else {
+                    d_msg = (static_cast<uint128_t>(j) * static_cast<uint128_t>(digitsKS[k].ConvertToInt()) * qPK_128 +
+                             qfrom_128 / 2) /
+                            qfrom_128;
+                    if (svi_128 != 1)
+                        d_msg = qPK.ConvertToInt() - d_msg;
+                }
+                // uint64_t expected =
+                //     sv[i]
+                //         .ModMulFast(j * digitsKS[k], qPK, mu)
+                //         .ConvertToInt();
+                // if (msg != expected) {
+                //     std::cout << msg << " ### " << expected << '\n';
+                // }
+                for (usint t = 0; t < nOnes; t++)
+                    b.ModAddAtIndexEq(t, d_msg);
+
+                vector2A[k] = std::move(a);
+                vector2B[k] = std::move(b);
+            }
+            vector1A[j] = std::move(vector2A);
+            vector1B[j] = std::move(vector2B);
+        }
+        resultVecA[i] = std::move(vector1A);
+        resultVecB[i] = std::move(vector1B);
+    }
+
+    return std::make_shared<RLWESwitchingKeyImpl>(RLWESwitchingKeyImpl(resultVecA, resultVecB));
+}
+
+// #define KS_BENCH
+#define KS_PAR_N 16
+// public functional key switching from (qfrom,N) to (Q,N)
+RLWECiphertext BinFHEScheme::FunctionalKeySwitch(
+    const std::shared_ptr<BinFHECryptoParams> params, ConstRLWESwitchingKey K, usint nOnes,
+    const std::vector<std::pair<ConstLWECiphertext, size_t>>& messages) const {
+    // NOTE: key switching from LWE(q,N) to LWE(q,n) takes approximately 20ms on that server
+    // but key switching takes 70ms on this server, and RLWE packing takes 220ms for each input ciphertext
+
+    auto LWEparams      = params->GetLWEParams();
+    auto RGSWparams     = params->GetRingGSWParams();
+    uint32_t N          = LWEparams->GetN();
+    NativeInteger qPK   = LWEparams->GetQ();
+    uint32_t basePK     = RGSWparams->GetBasePK();
+    NativeInteger qfrom = RGSWparams->GetQfrom();
+    auto polyparams     = RGSWparams->GetPolyParams();
+    uint32_t digitCount = (uint32_t)std::ceil(log(qfrom.ConvertToDouble()) / log(static_cast<double>(basePK)));
+    uint32_t dim_in     = messages[0].first->GetLength();
+    bool multithread = false;  // params->GetMultithread(); // XXX: multithread only controls parallelism of bootstraps
+
+    // sanity check
+    auto n_msg     = messages.size();
+    auto in_length = messages[0].first->GetLength();
+    for (usint i = 1; i < n_msg; i++) {
+        if (messages[i].first->GetLength() != in_length)
+            OPENFHE_THROW(openfhe_error, "input params do not match in input ciphertexts");
+    }
+    // switch ctqn_pos and ctqn_neg's modulus to 2N
+    std::vector<LWECiphertext> messages_ms(n_msg);
+    for (usint i = 0; i < n_msg; i++) {
+        if (messages[i].first->GetModulus() != qfrom)
+            messages_ms[i] = LWEscheme->ModSwitch(qfrom, messages[i].first);
+        else
+            messages_ms[i] = std::make_shared<LWECiphertextImpl>(*messages[i].first);
+    }
+
+    // creates empty ciphertext
+    NativeVector a(N, qPK);
+    NativeVector b(N, qPK);
+
+    auto qPK_128 = static_cast<uint128_t>(qPK.ConvertToInt()), qfrom_128 = static_cast<uint128_t>(qfrom.ConvertToInt());
+
+    std::vector<NativeVector> a_msg_par(n_msg), b_msg_par(n_msg);
+    for (size_t i = 0; i < n_msg; i++) {
+        a_msg_par[i] = NativeVector(N, qPK);
+        b_msg_par[i] = NativeVector(N, qPK);
+    }
+    uint64_t max_add_count       = uint64_t(-1) / (qPK.ConvertToInt() * digitCount);  // NOTE: worst case estimation
+    NativeInteger max_sub_buffer = max_add_count * qPK * digitCount;
+    omp_set_nested(1);
+#pragma omp parallel for num_threads(n_msg)
+    for (usint i = 0; i < n_msg; i++) {  // msg[i]
+        size_t cur_shift = messages[i].second % (2 * N);
+
+        auto cur_b = messages_ms[i]->GetB();
+        NativeInteger cur_b_coeff =
+            static_cast<uint64_t>((static_cast<uint128_t>(cur_b.ConvertToInt()) * qPK_128 + qfrom_128 / 2) / qfrom_128);
+        for (usint j = 0; j < nOnes; j++)
+            b_msg_par[i][j].ModAddFastEq(cur_b_coeff, qPK);
+
+        auto& cur_A = messages_ms[i]->GetA();
+#ifdef KS_BENCH
+        // 8 -> 23ms
+        // 16 -> 12ms
+        // 32 -> 10~20ms
+        if (multithread)
+            std::cout << "number of threads set to " << KS_PAR_N << '\n';
+        else
+            std::cout << "multithreading is disabled\n";
+        auto t_start = std::chrono::steady_clock::now();
+#endif
+        size_t n_threads = multithread ? KS_PAR_N : 1;
+        // accelerate KS using map-reduce
+        std::vector<NativeVector> a_par(n_threads), b_par(n_threads);
+        NativeVector init_vec(N, qPK);
+        for (size_t j = 0; j < N; j++)
+            init_vec[j] = max_sub_buffer;
+        for (size_t par = 0; par < n_threads; par++) {  // NOTE: fast arithmetic
+            a_par[par] = init_vec;
+            b_par[par] = init_vec;
+        }
+// map
+#pragma omp parallel for num_threads(n_threads)
+        for (size_t par = 0; par < n_threads; par++) {
+            auto j_start = par * dim_in / n_threads, j_end = (par + 1) * dim_in / n_threads;
+            // for i-th message, [j,digit,k]: s[j] * digit * basePK^k
+            for (size_t j = j_start, add_ctr = 1; j < j_end; ++j, ++add_ctr) {  // s[j]
+                NativeInteger atmp = cur_A[j];
+                for (size_t k = 0; k < digitCount; ++k, atmp /= basePK) {
+                    uint64_t digit = (atmp % basePK).ConvertToInt();
+                    if (digit > 0) {  // NOTE: skip when digit = 0
+                        // m[i]*(1+X+X^2+...+X^(nOnes/2))*X^shift
+                        a_par[par].SubEq(K->GetElementsA()[j][digit][k]);
+                        b_par[par].SubEq(K->GetElementsB()[j][digit][k]);
+                        // NOTE: non-modular subtraction
+                    }
+                }
+                if (add_ctr >= max_add_count) {  // NOTE: reduce
+                    add_ctr = 0;
+                    a_par[par].ModReduce();
+                    b_par[par].ModReduce();
+                    a_par[par].AddEq(max_sub_buffer - qPK);
+                    b_par[par].AddEq(max_sub_buffer - qPK);
+                }
+            }
+        }
+        // reduce
+        for (size_t par = 0; par < n_threads; par++) {
+            a_par[par].ModReduce();
+            b_par[par].ModReduce();
+            a_msg_par[i].ModAddEq(a_par[par]);
+            b_msg_par[i].ModAddEq(b_par[par]);
+        }
+        a_msg_par[i] = a_msg_par[i].ShiftRightNegacyclic(cur_shift);
+        b_msg_par[i] = b_msg_par[i].ShiftRightNegacyclic(cur_shift);
+#ifdef KS_BENCH
+        auto t_end = std::chrono::steady_clock::now();
+        std::cout << "RLWE Packing for each message takes " << (t_end - t_start).count() << " ns\n";
+#endif
+    }
+    for (size_t i = 0; i < n_msg; i++) {
+        a.ModAddEq(a_msg_par[i]);
+        b.ModAddEq(b_msg_par[i]);
+    }
+
+    return vecs_to_RLWECiphertext({std::move(a), std::move(b)}, polyparams);
+}
+
+RLWECiphertext BinFHEScheme::FunctionalKeySwitchSimple(
+    const std::shared_ptr<BinFHECryptoParams> params, ConstRLWESwitchingKey K, usint nOnes,
+    const std::vector<std::pair<ConstLWECiphertext, size_t>>& messages) const {
+    auto LWEparams      = params->GetLWEParams();
+    auto RGSWparams     = params->GetRingGSWParams();
+    uint32_t N          = LWEparams->GetN();
+    NativeInteger qPK   = LWEparams->GetQ();
+    uint32_t basePK     = RGSWparams->GetBasePK();
+    NativeInteger qfrom = RGSWparams->GetQfrom();
+    auto polyparams     = RGSWparams->GetPolyParams();
+    uint32_t digitCount = (uint32_t)std::ceil(log(qfrom.ConvertToDouble()) / log(static_cast<double>(basePK)));
+    uint32_t dim_in     = messages[0].first->GetLength();
+
+    // sanity check
+    auto n_msg     = messages.size();
+    auto in_length = messages[0].first->GetLength();
+    for (usint i = 1; i < n_msg; i++) {
+        if (messages[i].first->GetLength() != in_length)
+            OPENFHE_THROW(openfhe_error, "input params do not match in input ciphertexts");
+    }
+    // switch ctqn_pos and ctqn_neg's modulus to 2N
+    std::vector<LWECiphertext> messages_ms(n_msg);
+    for (usint i = 0; i < n_msg; i++) {
+        if (messages[i].first->GetModulus() != qfrom)
+            messages_ms[i] = LWEscheme->ModSwitch(qfrom, messages[i].first);
+        else
+            messages_ms[i] = std::make_shared<LWECiphertextImpl>(*messages[i].first);
+    }
+
+    // creates empty ciphertext
+    NativeVector a(N, qPK);
+    NativeVector b(N, qPK);
+
+    auto qPK_128 = static_cast<uint128_t>(qPK.ConvertToInt()), qfrom_128 = static_cast<uint128_t>(qfrom.ConvertToInt());
+
+    for (usint i = 0; i < n_msg; i++) {  // msg[i]
+
+        auto cur_b = messages_ms[i]->GetB();
+        NativeInteger cur_b_coeff =
+            static_cast<uint64_t>((static_cast<uint128_t>(cur_b.ConvertToInt()) * qPK_128 + qfrom_128 / 2) / qfrom_128);
+        for (usint j = 0; j < nOnes; j++)
+            b[j].ModAddFastEq(cur_b_coeff, qPK);
+
+        auto& cur_A = messages_ms[i]->GetA();
+
+        // for i-th message, [j,digit,k]: s[j] * digit * basePK^k
+        for (size_t j = 0; j < dim_in; ++j) {  // s[j]
+            NativeInteger atmp = cur_A[j];
+            for (size_t k = 0; k < digitCount; ++k, atmp /= basePK) {
+                uint64_t digit = (atmp % basePK).ConvertToInt();
+                if (digit > 0) {  // NOTE: skip when digit = 0
+                    // m[i]*(1+X+X^2+...+X^(nOnes/2))*X^shift
+                    a.ModSubEq(K->GetElementsA()[j][digit][k]);
+                    b.ModSubEq(K->GetElementsB()[j][digit][k]);
+                }
+            }
+        }
+    }
+
+    return vecs_to_RLWECiphertext({std::move(a), std::move(b)}, polyparams);
+}
+
+// NTL::ZZ_pX BinFHEScheme::ToZZpX(const NativeVector& vec) const {
+//     // NTL::ZZ_p::init(NTL::ZZ(vec.GetModulus().ConvertToInt()));
+//     NTL::ZZ_pX poly;
+//     auto N = vec.GetLength();
+//     poly.SetLength(N);
+//     for (decltype(N) i = 0; i < N; i++)
+//         poly[i] = vec[i].ConvertToInt();
+//     return poly;
+// }
+
+// NativeVector BinFHEScheme::FromZZpX(const NTL::ZZ_pX& poly) const {
+//     auto N       = poly.rep.length();
+//     auto modulus = NTL::conv<uint64_t>(NTL::ZZ_p::modulus());
+//     NativeVector vec(N, modulus);
+//     for (decltype(N) i = 0; i < N; i++)
+//         vec[i] = NativeInteger(NTL::conv<uint64_t, NTL::ZZ_p>(poly[i])).Mod(modulus);
+//     return vec;
+// }
+
+/**
+ * NOTE: this function is optimized for power of 2 modulus and ternary s
+*/
+NativeVector BinFHEScheme::PolyMult(const NativeVector& a, const NativeVector& s) const {
+    if (a.GetLength() != s.GetLength() || a.GetModulus() != s.GetModulus())
+        OPENFHE_THROW(openfhe_error, "mismatched params");
+    auto N       = a.GetLength();
+    auto modulus = a.GetModulus();
+    NativeVector ans(N, modulus);
+#pragma omp parallel for
+    for (usint i = 0; i < N; i++) {
+        if (s[i] > 0) {  // s[i] == 1
+            for (usint j = 0; j < i; j++)
+                ans[j] -= a[j - i + N];
+            for (usint j = i; j < N; j++)
+                ans[j] += a[j - i];
+        }
+        else if (s[i] < 0) {  // s[i] == -1
+            for (usint j = 0; j < i; j++)
+                ans[j] += a[j - i + N];
+            for (usint j = i; j < N; j++)
+                ans[j] -= a[j - i];
+        }
+        // s[i] == 0
+    }
+    for (usint i = 0; i < N; i++)
+        ans[i].ModEq(modulus);
+    return ans;
+}
+
+// std::vector<LWECiphertext> BinFHEScheme::ExtractMultipleMessages(ConstLWECiphertext ct,
+//                                                                  const std::vector<std::pair<size_t, size_t>>& msg_info,
+//                                                                  size_t padding) const {
+//     return std::vector<LWECiphertext>();
+// }
+
+LWECiphertext BinFHEScheme::EvalNegate(ConstLWECiphertext ct) const {
+    auto len     = ct->GetLength();
+    auto modulus = ct->GetModulus();
+    NativeVector a(len, modulus);
+    a.ModSubEq(ct->GetA());
+    NativeInteger b = 0;
+    b.ModSubFastEq(ct->GetB(), modulus);
+    return std::make_shared<LWECiphertextImpl>(a, b);
+}
+
+LWECiphertext BinFHEScheme::ExtractACC(RLWECiphertext acc) const {
+    std::vector<NativePoly>& accVec = acc->GetElements();
+    // the accumulator result is encrypted w.r.t. the transposed secret key
+    // we can transpose "a" to get an encryption under the original secret key
+    accVec[0] = accVec[0].Transpose();
+    accVec[0].SetFormat(Format::COEFFICIENT);
+    accVec[1].SetFormat(Format::COEFFICIENT);
+
+    auto ctExt = std::make_shared<LWECiphertextImpl>(std::move(accVec[0].GetValues()), std::move(accVec[1][0]));
+    return ctExt;
+}
+
+LWECiphertext BinFHEScheme::ManualExtract(ConstRLWECiphertext acc, size_t pos) const {
+    if (acc->GetElements()[0].GetFormat() != Format::COEFFICIENT ||
+        acc->GetElements()[1].GetFormat() != Format::COEFFICIENT)
+        OPENFHE_THROW(openfhe_error, "can only extract LWE from RLWE in coefficient format");
+
+    auto N = acc->GetElements()[0].GetLength();
+    auto Q = acc->GetElements()[0].GetModulus();
+    if (pos >= N)
+        OPENFHE_THROW(openfhe_error, "index out of bound");
+    NativeVector a(N, Q);
+    NativeInteger b = acc->GetElements()[1][pos];
+    auto& poly_a    = acc->GetElements()[0];
+
+    for (size_t i = 0; i <= pos; i++)
+        a[i] = poly_a[pos - i];
+    for (size_t i = pos + 1; i < N; i++)
+        a[i] = NativeInteger(0).ModSubFast(poly_a[pos + N - i], Q);
+
+    return std::make_shared<LWECiphertextImpl>(std::move(a), std::move(b));
+}
+
+std::vector<RLWECiphertext> BinFHEScheme::PrepareRLWEPrime(const std::shared_ptr<BinFHECryptoParams> params,
+                                                           const RingGSWBTKey& EK, ConstLWECiphertext ct,
+                                                           NativeInteger beta, size_t p, bool FDFB) const {
+    auto LWEparams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    size_t baseGMV   = RGSWparams->GetBaseGMV();
+    auto polyparams  = RGSWparams->GetPolyParams();
+    NativeInteger Q  = LWEparams->GetQ();
+    auto N           = LWEparams->GetN();
+    bool multithread = params->GetMultithread();
+
+    size_t dMV = static_cast<size_t>(std::ceil(log(double(2 * p)) / log(double(baseGMV))));
+
+    std::vector<RLWECiphertext> rlwe_prime;
+    uint128_t Q_128 = static_cast<uint128_t>(Q.ConvertToInt()), baseGMV_128 = static_cast<uint128_t>(baseGMV),
+              p_128 = static_cast<uint128_t>(p), dp_128 = static_cast<uint128_t>(p * 2);
+    if (!FDFB)  // non full domain, generate RLWE ciphertexts encrypting Q/2p * TV_0 * X^m * B_i
+        rlwe_prime.resize(dMV);
+    else
+        rlwe_prime.resize(
+            dMV *
+            2);  // full domain, generate RLWE ciphertexts encrypting Q/2p * TV_0 * X^m * B_i and Q/2p * sgn(m) * TV_0 * X^m * B^i
+    uint128_t power_128 = 1;
+    std::vector<NativeInteger> powers(dMV);
+    for (size_t i = 0; i < dMV; i++, power_128 *= baseGMV_128)
+        powers[i] = static_cast<uint64_t>((Q_128 * power_128 + p_128) / dp_128);  // round(Q/2p * B^i)
+    if (multithread) {
+#pragma omp parallel for num_threads(dMV)
+        for (size_t i = 0; i < dMV; i++) {
+            NativePoly a(polyparams, Format::COEFFICIENT, true), b(polyparams, Format::COEFFICIENT, true);
+            for (size_t j = 0; j < N; j++)
+                b[j] = powers[i];
+            rlwe_prime[i] = BootstrapCtxtCore(params, EK.BSkey, ct,
+                                              std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{a, b}));
+        }
+    }
+    else {
+        for (size_t i = 0; i < dMV; i++) {
+            NativePoly a(polyparams, Format::COEFFICIENT, true), b(polyparams, Format::COEFFICIENT, true);
+            for (size_t j = 0; j < N; j++)
+                b[j] = powers[i];
+            rlwe_prime[i] = BootstrapCtxtCore(params, EK.BSkey, ct,
+                                              std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{a, b}));
+        }
+    }
+    // FIXME: the following branch is not tested
+    // TODO: multithreading
+    if (FDFB) {  // now generate [sgn(m) * TV_0 * X^m * B^i]:(1) generate [sgn(m) * B^i * Q/2p]. (2) use RLWE packing with nOnes = 1. (3) bootstrap by ct
+        std::vector<std::pair<NativeInteger, NativeInteger>> pn_values(dMV);
+        for (size_t i = 0; i < dMV; i++) {
+            pn_values[i].first  = 0;
+            pn_values[i].second = powers[i];  // round(Q/2p * B^i)
+        }
+        auto extracted = BatchSelect(params, EK, ct, beta, pn_values);  // batch select
+        for (size_t i = 0; i < dMV; i++)
+            rlwe_prime[dMV + i] = BootstrapCtxtCore(
+                params, EK.BSkey, ct,
+                FunctionalKeySwitch(params, EK.PKkey_full, N, {std::make_pair(extracted[i], 0)}));  // mult by X^m
+    }
+    return rlwe_prime;
+}
+
+std::vector<LWECiphertext> BinFHEScheme::BatchSelect(
+    const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK, ConstLWECiphertext ct, NativeInteger beta,
+    const std::vector<std::pair<NativeInteger, NativeInteger>>& pn_values) const {
+    auto LWEparams   = params->GetLWEParams();
+    auto RGSWparams  = params->GetRingGSWParams();
+    auto N           = LWEparams->GetN();
+    NativeInteger Q  = LWEparams->GetQ();
+    auto polyparams  = RGSWparams->GetPolyParams();
+    bool multithread = params->GetMultithread();
+
+    // (-beta \pm beta) 0 (beta \pm beta)
+    size_t batch   = (N / (4 * beta)).ConvertToInt();  // each bts can handle selection of batch pairs
+    auto half_step = 2 * beta.ConvertToInt();
+    auto q         = ct->GetModulus();
+
+    size_t n_pairs = pn_values.size();
+    size_t n_tv    = (n_pairs + batch - 1) / batch;
+    std::vector<LWECiphertext> ans(n_pairs);
+
+    if (n_pairs == 0)
+        OPENFHE_THROW(openfhe_error, "pn_values is empty");
+    if (multithread) {  // if multithreading is enabled, directly obtain results using parallel BTS
+#pragma omp parallel for num_threads(n_pairs)
+        for (size_t i = 0; i < n_pairs; i++) {
+            auto cur_pos = pn_values[i].first, cur_neg = pn_values[i].second;
+            auto cur_middle = (cur_pos + cur_neg + 1) / 2;
+            auto cur_bias   = cur_pos.ModSubFast(cur_middle, Q);
+            // cur_pos = cur_middle + cur_bias, cur_neg = cur_middle - cur_bias
+            auto fLUT = [cur_bias](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)  // pos
+                    return cur_bias;
+                else  // neg
+                    return (Q - cur_bias).Mod(Q);
+            };
+            auto ct_bias = BootstrapFunc(params, EK, ct, fLUT, Q, true);  // raw ctxt
+            LWEscheme->EvalAddConstEq(ct_bias, cur_middle);
+            ans[i] = std::make_shared<LWECiphertextImpl>(std::move(*ct_bias));
+        }
+        return ans;
+    }
+    if (n_pairs <= 2) {  // no more than 2 values are needed, directly obtain them using BTS
+        for (size_t i = 0; i < n_pairs; i++) {
+            auto cur_pos = pn_values[i].first, cur_neg = pn_values[i].second;
+            auto cur_middle = (cur_pos + cur_neg + 1) / 2;
+            auto cur_bias   = cur_pos.ModSubFast(cur_middle, Q);
+            // cur_pos = cur_middle + cur_bias, cur_neg = cur_middle - cur_bias
+            auto fLUT = [cur_bias](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+                if (x < q / 2)  // pos
+                    return cur_bias;
+                else  // neg
+                    return (Q - cur_bias).Mod(Q);
+            };
+            auto ct_bias = BootstrapFunc(params, EK, ct, fLUT, Q, true);  // raw ctxt
+            LWEscheme->EvalAddConstEq(ct_bias, cur_middle);
+            ans[i] = std::make_shared<LWECiphertextImpl>(std::move(*ct_bias));
+        }
+        return ans;
+    }
+
+    //  note that this optimization works only for plaintext TV
+    auto fLUTsgn = [batch](NativeInteger x, NativeInteger q, NativeInteger Q) -> NativeInteger {
+        if (x < q / 2)
+            return Q / (8 * batch);
+        else
+            return Q - Q / (8 * batch);
+    };
+    auto ct_sgn = BootstrapFunc(params, EK, ct, fLUTsgn, q);
+
+    size_t pairs_remaining = n_pairs;
+    for (size_t i = 0; i < n_tv; i++, pairs_remaining -= batch) {  // i-th batch BTS
+        // first prepare the packed tv
+        NativePoly a(polyparams, Format::COEFFICIENT, true), b(polyparams, Format::COEFFICIENT, true);
+        for (size_t j = 0, end = std::min(batch, pairs_remaining); j < end; j++) {  // j-th pair
+            auto cur_pos = pn_values[i * batch + j].first, cur_neg = pn_values[i * batch + j].second;
+            if (j == 0) {
+                auto cur_pos_negate = NativeInteger(0).ModSubFast(cur_pos, Q);
+                for (size_t k = 0; k < half_step; k++) {  // iterate coefficients with k
+                    b[k]         = cur_neg;
+                    b[N - 1 - k] = cur_pos_negate;
+                }
+            }
+            else {
+                for (size_t k = (2 * j - 1) * half_step; k < 2 * j * half_step; k++) {
+                    b[k]             = cur_pos;
+                    b[k + half_step] = cur_neg;
+                }
+            }
+        }
+        // bootstrap it
+        auto ct_sel = BootstrapCtxtCore(params, EK.BSkey, ct_sgn,
+                                        std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{a, b}));
+        ct_sel->SetFormat(Format::COEFFICIENT);
+        // extract
+        for (size_t j = 0, end = std::min(batch, pairs_remaining); j < end; j++) {  // j-th pair
+            ans[i * batch + j] = ManualExtract(ct_sel, j * 2 * half_step);
+        }
+    }
+    return ans;
+}
+
+std::vector<NativePoly> BinFHEScheme::SignedDecomp(const std::shared_ptr<BinFHECryptoParams> params,
+                                                   const NativePoly& poly, size_t q, size_t B) const {
+    if (poly.GetFormat() != Format::COEFFICIENT)
+        OPENFHE_THROW(openfhe_error, "signed decomp expects input to be in coefficient form");
+
+    auto RGSWparams = params->GetRingGSWParams();
+    auto LWEparams  = params->GetLWEParams();
+
+    auto polyparams = RGSWparams->GetPolyParams();
+    auto Q          = LWEparams->GetQ();
+    auto N          = LWEparams->GetN();
+
+    size_t d = static_cast<size_t>(std::ceil(log(double(q)) / log(double(B))));
+
+    std::vector<NativePoly> ans(d);
+    for (size_t i = 0; i < d; i++) {
+        ans[i] = NativePoly(polyparams, Format::COEFFICIENT, true);
+    }
+    int64_t half_Q = (Q.ConvertToInt() + 1) / 2, half_B = (B + 1) / 2,
+            Q_signed = static_cast<int64_t>(Q.ConvertToInt());  // we use (q+1)/2 to conform with 2'complement
+    for (size_t i = 0; i < N; i++) {
+        int64_t tmp_coeff = poly[i].ConvertToInt();
+        if (tmp_coeff >= half_Q)
+            tmp_coeff -= Q_signed;
+        for (size_t j = 0; j < d; j++) {
+            int64_t rem = tmp_coeff % B;
+            if (rem >= half_B)
+                rem -= B;
+            tmp_coeff -= rem;
+            tmp_coeff /= B;
+            if (rem < 0)
+                rem += Q_signed;
+            ans[j][i] = rem;
+        }
+    }
+    for (size_t i = 0; i < d; i++)
+        ans[i].SetFormat(Format::EVALUATION);
+    return ans;
+}
+
+RLWECiphertext BinFHEScheme::InnerProduct(const std::vector<RLWECiphertext>& rlwe_prime,
+                                          const std::vector<NativePoly>& decomposed) const {
+    auto polyparams = decomposed[0].GetParams();
+    NativePoly a(polyparams, Format::EVALUATION, true), b(polyparams, Format::EVALUATION, true);
+    if (rlwe_prime.size() != decomposed.size())
+        OPENFHE_THROW(openfhe_error, "length mismatch in inner product");
+    size_t length = rlwe_prime.size();
+    for (size_t i = 0; i < length; i++) {
+        a += rlwe_prime[i]->GetElements()[0] * decomposed[i];
+        b += rlwe_prime[i]->GetElements()[1] * decomposed[i];
+    }
+    return std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{a, b});
+}
+
+// NOTE: we assume the input polynomials are in coefficient format (which is default format after LWE-to-RLWE packing)
+// ct1 is directly extended, while ct2 is mod switched before expansion
+// output ciphertext is in NTT domain
+RLWECiphertext BinFHEScheme::BFVMult(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                     const RLWECiphertext& ct1, const RLWECiphertext& ct2, uint32_t p) const {
+    auto LWEparams    = params->GetLWEParams();
+    auto RGSWparams   = params->GetRingGSWParams();
+    auto Q            = RGSWparams->GetQ();
+    auto P            = RGSWparams->GetP();
+    auto N            = RGSWparams->GetN();
+    auto baseRL       = RGSWparams->GetBaseRL();
+    auto polyparams_Q = RGSWparams->GetPolyParams();
+    auto polyparams_P = RGSWparams->GetPolyParamsP();
+
+    if (ct1->GetElements()[0].GetFormat() != Format::COEFFICIENT ||
+        ct2->GetElements()[0].GetFormat() != Format::COEFFICIENT)
+        OPENFHE_THROW(openfhe_error, "bfv mult expects input to be in coefficient format");
+
+    // auto t_start = std::chrono::steady_clock::now();
+
+    auto ct1_eles = ct1->GetElements(), ct2_eles = ct2->GetElements();
+    // Basis extension
+    std::vector<NativePoly> ct1_eles_QP[2],
+        ct2_eles_QP[2];               // outer idx 0 = mod Q, 1 = mod P. inner idx = ctxt component component
+    for (size_t i = 0; i < 2; i++) {  // Q,P idx
+        ct1_eles_QP[i] = std::vector<NativePoly>(2);
+        ct2_eles_QP[i] = std::vector<NativePoly>(2);
+    }
+    for (size_t j = 0; j < 2; j++) {  // ctxt component idx
+        NativeVector tmp;
+        // extend ct1 to P
+        ct1_eles_QP[0][j] = ct1_eles[j];
+        ct1_eles_QP[1][j] = NativePoly(polyparams_P);
+        tmp               = ct1_eles[j].GetValues().Mod(P);
+        tmp.SetModulus(P);
+        ct1_eles_QP[1][j].SetValues(tmp, Format::COEFFICIENT);
+        // mod switch ct2 to P, then extend it to Q
+        ct2_eles_QP[1][j] = NativePoly(polyparams_P);
+        ct2_eles_QP[1][j].SetValues(ModSwitch(P, ct2_eles[j].GetValues()), Format::COEFFICIENT);
+
+        ct2_eles_QP[0][j] = NativePoly(polyparams_Q);
+        tmp               = ct2_eles_QP[1][j].GetValues().Mod(Q);
+        tmp.SetModulus(Q);
+        ct2_eles_QP[0][j].SetValues(tmp, Format::COEFFICIENT);
+        // set all to evaluation form
+        ct1_eles_QP[0][j].SetFormat(Format::EVALUATION);
+        ct1_eles_QP[1][j].SetFormat(Format::EVALUATION);
+        ct2_eles_QP[0][j].SetFormat(Format::EVALUATION);
+        ct2_eles_QP[1][j].SetFormat(Format::EVALUATION);
+    }
+    // tensor product
+    std::vector<NativePoly> tensors[2];       // outer idx = Q,P idx, inner idx = ctxt component idx
+    tensors[0] = std::vector<NativePoly>(3);  // 1, -s, s2 mod Q
+    tensors[1] = std::vector<NativePoly>(3);  // 1, -s, s2 mod P
+    for (size_t i = 0; i < 2; i++) {
+        // input ctxt = (a,b) encrypts m = b - as
+        // output ctxt = (b1b2, -a1b2-a2b1, a1a2)*(1,s,s^2) = (b1b2, a1b2+a2b1, a1a2)*(1,-s,s^2)
+        // use karatsuba
+        tensors[i][0] = ct1_eles_QP[i][1] * ct2_eles_QP[i][1];  // b1 * b2
+        tensors[i][2] = ct1_eles_QP[i][0] * ct2_eles_QP[i][0];  // a1 * a2
+        // (a1+b1)*(a2+b2) - a1*a2 - b1*b2
+        tensors[i][1] = (ct1_eles_QP[i][0] + ct1_eles_QP[i][1]) * (ct2_eles_QP[i][0] + ct2_eles_QP[i][1]) -
+                        tensors[i][0] - tensors[i][2];
+    }
+    // (QP)/(p^2)m1m2 + ...: scale down by p/P to get Q/p*m1m2
+    // mult by p, convert to coefficient form
+    for (size_t i = 0; i < 2; i++)
+        for (size_t j = 0; j < 3; j++) {
+            tensors[i][j] *= p;
+            tensors[i][j].SetFormat(Format::COEFFICIENT);
+        }
+    // then rescale by P
+    auto halfP     = P >> 1;
+    auto invP_modQ = P.ModInverse(Q);
+    for (size_t j = 0; j < 3; j++) {  // for each ctxt component...
+        auto &cur_poly_Q = tensors[0][j], &cur_poly_P = tensors[1][j];
+        for (size_t k = 0; k < N; k++) {
+            // round to the nearest multiple of P
+            if (cur_poly_P[k] <= halfP)  // NOTE: we can use ModSubFastEq instead of ModSubEq as long as halfP < Q
+                cur_poly_Q[k].ModSubFastEq(cur_poly_P[k], Q);
+            else
+                cur_poly_Q[k].ModAddFastEq(P - cur_poly_P[k], Q);
+        }
+        cur_poly_Q *= invP_modQ;
+    }
+    // key switching
+    tensors[0][2].SetFormat(Format::COEFFICIENT);
+    auto relined_ctxt = InnerProduct(*EK.BFV_relin_keys, SignedDecomp(params, tensors[0][2], Q.ConvertToInt(), baseRL));
+    relined_ctxt->SetFormat(Format::COEFFICIENT);
+    relined_ctxt->GetElements()[0] += tensors[0][1];
+    relined_ctxt->GetElements()[1] += tensors[0][0];
+
+    // auto t_end = std::chrono::steady_clock::now();
+    // std::cout << "BFV mult takes " << (t_end - t_start).count() << "ns\n";
+
+    return relined_ctxt;
+}
+
+std::shared_ptr<std::vector<RLWECiphertext>> BinFHEScheme::GenBFVRelinKeys(
+    const std::shared_ptr<BinFHECryptoParams> params, const NativePoly& skNTT) const {
+    auto RGSWparams = params->GetRingGSWParams();
+    auto baseRL     = RGSWparams->GetBaseRL();
+    auto Q          = RGSWparams->GetQ();
+    auto polyparams = RGSWparams->GetPolyParams();
+
+    size_t dRL = (uint32_t)std::ceil(log(Q.ConvertToDouble()) / log(static_cast<double>(baseRL)));
+    std::vector<RLWECiphertext> rlwe_prime(dRL);
+
+    auto dug = DiscreteUniformGeneratorImpl<NativeVector>();
+    dug.SetModulus(Q);
+
+    // generate RLWE encryptions of sk^2*B_rl^i
+    auto skNTT2          = skNTT * skNTT;
+    NativeInteger powerB = 1;
+    for (size_t i = 0; i < dRL; i++, powerB *= baseRL) {
+        NativePoly apoly(dug, polyparams, Format::EVALUATION);  // directly sample in NTT domain
+        NativePoly bpoly(RGSWparams->GetDgg(), polyparams, Format::COEFFICIENT);
+        bpoly.SetFormat(Format::EVALUATION);
+        bpoly += apoly * skNTT;
+        bpoly += skNTT2 * powerB;  // b = as + e + sk^2*B_rl^i
+        rlwe_prime[i] = std::make_shared<RLWECiphertextImpl>(std::vector<NativePoly>{apoly, bpoly});
+    }
+    return std::make_shared<std::vector<RLWECiphertext>>(rlwe_prime);
+}
+
+/**
+ * Note that the representations of tv + Ip are equivalent
+ * however under unsigned representation [0,p-1], the tv1 corresponding to [1,1,...,p-1,p-1] is [p,0...,p-2,...] instead of [0,...,-2,...]
+ * as we use the two's complement representation here
+*/
+NativeVector BinFHEScheme::ComputeTV1(const NativeVector& tv) const {
+    auto p          = tv.GetModulus();  // plaintext modulus
+    auto N          = tv.GetLength();
+    int64_t ps      = p.ConvertToInt();
+    int64_t half_ps = ps >> 1, dps = ps << 1;
+    NativeVector tv1(N, 2 * p);
+    std::vector<int64_t> tv_signed(N);
+    int64_t tmp;
+    // reduce to two's complement form
+    for (size_t i = 0; i < N; i++) {
+        tmp          = tv[i].ConvertToInt();
+        tv_signed[i] = (tmp >= half_ps) ? (tmp - ps) : tmp;
+    }
+    tmp = tv_signed[0] + tv_signed[N - 1];
+    if (tmp < 0)
+        tmp += dps;
+    tv1[0] = tmp;
+    for (size_t i = 1; i < N; i++) {
+        tmp = tv_signed[i] - tv_signed[i - 1];
+        if (tmp < 0)
+            tmp += dps;
+        tv1[i] = tmp;
+    }
+    return tv1;
+}
+
+void BinFHEScheme::inspect_lwe_ctxt(const std::shared_ptr<BinFHECryptoParams> params, const RingGSWBTKey& EK,
+                                    uint32_t p, ConstLWECiphertext ct, std::string name) const {
+    auto LWEParams = params->GetLWEParams();
+    LWEPlaintext ptxt;
+    LWEscheme->Decrypt(LWEParams, EK.skeyN, ct, &ptxt, ct->GetModulus().ConvertToInt());
+
+    std::cout << name << " = " << ptxt
+              << ", log2(noise) = " << std::log2(std::abs(inspect_lwe_ptxt(ptxt, p, ct->GetModulus()))) << '\n';
+}
+
+int64_t BinFHEScheme::inspect_lwe_ptxt(LWEPlaintext ptxt, uint32_t p, NativeInteger mod) const {
+    uint64_t cur_mod       = mod.ConvertToInt();
+    int64_t cur_mod_signed = cur_mod;
+    auto msg               = ((ptxt * p + cur_mod / 2) / cur_mod) % p;  // round(p/Q * ptxt)
+    auto msg_part          = ((msg * cur_mod + p / 2) / p) % cur_mod;   // round(Q/p * msg)
+    auto noise             = NativeInteger(msg_part).ModSub(ptxt, cur_mod);
+    int64_t signed_noise   = noise.ConvertToInt();
+    if (signed_noise >= cur_mod_signed / 2)
+        signed_noise -= cur_mod_signed;
+    return signed_noise;
+}
+
 };  // namespace lbcrypto
diff --git a/src/binfhe/lib/binfhecontext.cpp b/src/binfhe/lib/binfhecontext.cpp
index bbcbb79..fe87ece 100644
--- a/src/binfhe/lib/binfhecontext.cpp
+++ b/src/binfhe/lib/binfhecontext.cpp
@@ -48,8 +48,26 @@ void BinFHEContext::GenerateBinFHEContext(uint32_t n, uint32_t N, const NativeIn
     m_binfhescheme  = std::make_shared<BinFHEScheme>(method);
 }
 
+/**
+ * baseR is used only for DM method, it does not matter what we set it to
+*/
+void BinFHEContext::GenerateBinFHEContext(uint32_t n, uint32_t N, const NativeInteger& q, const NativeInteger& Q,
+                                          const NativeInteger& qKS, double std, uint32_t baseKS, uint32_t baseG,
+                                          uint32_t baseR, uint32_t basePK, const NativeInteger& qfrom, uint32_t baseG0,
+                                          uint32_t baseGMV, uint32_t beta_precise, uint32_t p,
+                                          const std::vector<uint32_t>& baseGs, uint32_t pkkey_flags, bool multithread,
+                                          const NativeInteger& P, uint32_t baseRL, BINFHE_METHOD method) {
+    auto lweparams  = std::make_shared<LWECryptoParams>(n, N, q, Q, qKS, std, baseKS);
+    auto rgswparams = std::make_shared<RingGSWCryptoParams>(N, Q, q, baseG, baseR, method, std, false, basePK, qfrom,
+                                                            baseG0, baseGMV, baseGs, pkkey_flags, P, baseRL);
+    m_params        = std::make_shared<BinFHECryptoParams>(lweparams, rgswparams, multithread);
+    m_binfhescheme  = std::make_shared<BinFHEScheme>(method);
+    m_beta_precise  = beta_precise;  // FIXME: still kind of ugly... this property should belong to a single EK
+    m_half_gap      = p > 0 ? (q.ConvertToInt() + p) / (2 * p) : 64;
+}
+
 void BinFHEContext::GenerateBinFHEContext(BINFHE_PARAMSET set, bool arbFunc, uint32_t logQ, int64_t N,
-                                          BINFHE_METHOD method, bool timeOptimization) {
+                                          BINFHE_METHOD method, bool timeOptimization, uint32_t B_g) {
     if (GINX != method) {
         std::string errMsg("ERROR: CGGI is the only supported method");
         OPENFHE_THROW(not_implemented_error, errMsg);
@@ -82,6 +100,8 @@ void BinFHEContext::GenerateBinFHEContext(BINFHE_PARAMSET set, bool arbFunc, uin
         baseG     = 1 << 5;
         logQprime = 27;
     }
+    if (B_g != 0)  // manual override
+        baseG = B_g;
 
     m_timeOptimization = timeOptimization;
     SecurityLevel sl   = HEStd_128_classic;
@@ -165,11 +185,11 @@ void BinFHEContext::GenerateBinFHEContext(BINFHE_PARAMSET set, BINFHE_METHOD met
     NativeInteger Q(
         PreviousPrime<NativeInteger>(FirstPrime<NativeInteger>(params.numberBits, params.cyclOrder), params.cyclOrder));
 
-    usint ringDim  = params.cyclOrder / 2;
-    auto lweparams = (PRIME == params.modKS) ?
-                         std::make_shared<LWECryptoParams>(params.latticeParam, ringDim, params.mod, Q, Q,
+    usint ringDim   = params.cyclOrder / 2;
+    auto lweparams  = (PRIME == params.modKS) ?
+                          std::make_shared<LWECryptoParams>(params.latticeParam, ringDim, params.mod, Q, Q,
                                                            params.stdDev, params.baseKS) :
-                         std::make_shared<LWECryptoParams>(params.latticeParam, ringDim, params.mod, Q, params.modKS,
+                          std::make_shared<LWECryptoParams>(params.latticeParam, ringDim, params.mod, Q, params.modKS,
                                                            params.stdDev, params.baseKS);
     auto rgswparams = std::make_shared<RingGSWCryptoParams>(ringDim, Q, params.mod, params.gadgetBase, params.baseRK,
                                                             method, params.stdDev);
@@ -218,12 +238,22 @@ void BinFHEContext::BTKeyGen(ConstLWEPrivateKey sk) {
 
     auto temp = RGSWParams->GetBaseG();
 
-    if (m_timeOptimization) {
-        auto gpowermap = RGSWParams->GetGPowerMap();
+    auto skN = m_LWEscheme->KeyGen(RGSWParams->GetN(), RGSWParams->GetQ());
+
+    if (RGSWParams->GetGPowerMap().size() > 0) {
+        auto gpowermap    = RGSWParams->GetGPowerMap();
+        bool init         = false;
+        uint32_t first_bg = 0;
         for (std::map<uint32_t, std::vector<NativeInteger>>::iterator it = gpowermap.begin(); it != gpowermap.end();
              ++it) {
             RGSWParams->Change_BaseG(it->first);
-            m_BTKey_map[it->first] = m_binfhescheme->KeyGen(m_params, sk);
+            if (!init) {  // reuse generated PK keys
+                m_BTKey_map[it->first] = m_binfhescheme->KeyGen(m_params, sk, skN, nullptr);
+                init                   = true;
+                first_bg               = it->first;
+            }
+            else
+                m_BTKey_map[it->first] = m_binfhescheme->KeyGen(m_params, sk, skN, &m_BTKey_map[first_bg]);
         }
         RGSWParams->Change_BaseG(temp);
     }
@@ -232,7 +262,7 @@ void BinFHEContext::BTKeyGen(ConstLWEPrivateKey sk) {
         m_BTKey = m_BTKey_map[temp];
     }
     else {
-        m_BTKey           = m_binfhescheme->KeyGen(m_params, sk);
+        m_BTKey           = m_binfhescheme->KeyGen(m_params, sk, skN, nullptr);
         m_BTKey_map[temp] = m_BTKey;
     }
 }
@@ -258,6 +288,101 @@ LWECiphertext BinFHEContext::EvalFunc(ConstLWECiphertext ct, const std::vector<N
     return m_binfhescheme->EvalFunc(m_params, m_BTKey, ct, LUT, beta);
 }
 
+LWECiphertext BinFHEContext::EvalFuncTest(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain,
+                                          double deltaout, NativeInteger qout, double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncTest(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncCompress(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                              double deltain, double deltaout, NativeInteger qout,
+                                              double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncCompress(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncCancelSign(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                                double deltain, double deltaout, NativeInteger qout,
+                                                double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncCancelSign(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncSelect(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                            double deltain, double deltaout, NativeInteger qout, double (*f)(double m),
+                                            uint32_t baseG_small) const {
+    NativeInteger beta = GetBetaPrecise();
+    auto it_small      = m_BTKey_map.find(baseG_small);
+    if (it_small == m_BTKey_map.end())
+        OPENFHE_THROW(openfhe_error, "EK not found");
+    return m_binfhescheme->EvalFuncSelect(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f,
+                                          it_small->second, baseG_small);
+}
+
+LWECiphertext BinFHEContext::EvalFuncSelectAlt(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                               double deltain, double deltaout, NativeInteger qout,
+                                               double (*f)(double m), uint32_t baseG_small) const {
+    NativeInteger beta = GetBetaPrecise();
+    auto it_small      = m_BTKey_map.find(baseG_small);
+    if (it_small == m_BTKey_map.end())
+        OPENFHE_THROW(openfhe_error, "EK not found");
+    return m_binfhescheme->EvalFuncSelectAlt(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f,
+                                             it_small->second, baseG_small);
+}
+
+LWECiphertext BinFHEContext::EvalFuncPreSelect(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                               double deltain, double deltaout, NativeInteger qout,
+                                               double (*f)(double m), NativeInteger p_mid) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncPreSelect(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f, p_mid);
+}
+
+LWECiphertext BinFHEContext::EvalFuncKS21(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain,
+                                          double deltaout, NativeInteger qout, double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncKS21(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncComp(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain,
+                                          double deltaout, NativeInteger qout, double (*f)(double m),
+                                          uint32_t f_property, double shift, uint32_t baseG_small) const {
+    NativeInteger beta = GetBetaPrecise();
+    auto it_small      = m_BTKey_map.find(baseG_small);
+    if (it_small == m_BTKey_map.end())
+        OPENFHE_THROW(openfhe_error, "EK not found");
+    return m_binfhescheme->EvalFuncComp(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f, f_property, shift,
+                                        it_small->second, baseG_small);
+}
+
+LWECiphertext BinFHEContext::EvalFuncBFV(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT, double deltain,
+                                         double deltaout, NativeInteger qout, double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncBFV(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncWoPPBS1(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                             double deltain, double deltaout, NativeInteger qout,
+                                             double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncWoPPBS1(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalFuncWoPPBS2(ConstLWECiphertext ct, const std::vector<NativeInteger>& LUT,
+                                             double deltain, double deltaout, NativeInteger qout,
+                                             double (*f)(double m)) const {
+    NativeInteger beta = GetBetaPrecise();
+    return m_binfhescheme->EvalFuncWoPPBS2(m_params, m_BTKey, ct, LUT, beta, deltain, deltaout, qout, f);
+}
+
+LWECiphertext BinFHEContext::EvalReLU(ConstLWECiphertext ct, ConstLWECiphertext ct_msd, size_t baseG_sgn,
+                                      size_t baseG_sel) const {
+    auto it_sgn = m_BTKey_map.find(baseG_sgn), it_sel = m_BTKey_map.find(baseG_sel);
+    if (it_sgn == m_BTKey_map.end() || it_sel == m_BTKey_map.end())
+        OPENFHE_THROW(openfhe_error, "EK not found");
+    auto beta = GetBeta().ConvertToInt();
+    return m_binfhescheme->EvalReLU(m_params, it_sgn->second, baseG_sgn, it_sel->second, baseG_sel, ct, ct_msd, beta);
+}
+
 LWECiphertext BinFHEContext::EvalFloor(ConstLWECiphertext ct, uint32_t roundbits) const {
     //    auto q = m_params->GetLWEParams()->Getq().ConvertToInt();
     //    if (roundbits != 0) {
@@ -275,9 +400,65 @@ LWECiphertext BinFHEContext::EvalSign(ConstLWECiphertext ct) {
     return m_binfhescheme->EvalSign(params, m_BTKey_map, ct, beta);
 }
 
-std::vector<LWECiphertext> BinFHEContext::EvalDecomp(ConstLWECiphertext ct) {
+std::vector<LWECiphertext> BinFHEContext::EvalDecomp(ConstLWECiphertext ct, bool CKKS) {
     NativeInteger beta = GetBeta();
-    return m_binfhescheme->EvalDecomp(m_params, m_BTKey_map, ct, beta);
+    return m_binfhescheme->EvalDecomp(m_params, m_BTKey_map, ct, beta, CKKS);
+}
+
+LWECiphertext BinFHEContext::EvalFloorAlt(ConstLWECiphertext ct, uint32_t roundbits) const {
+    //    auto q = m_params->GetLWEParams()->Getq().ConvertToInt();
+    //    if (roundbits != 0) {
+    //        NativeInteger newp = this->GetMaxPlaintextSpace();
+    //        SetQ(q / newp * (1 << roundbits));
+    //    }
+    //    SetQ(q);
+    //    return res;
+    return m_binfhescheme->EvalFloorAlt(m_params, m_BTKey, ct, GetBeta(), roundbits);
+}
+
+LWECiphertext BinFHEContext::EvalSignAlt(ConstLWECiphertext ct, bool fast, bool CKKS) {
+    auto params        = std::make_shared<BinFHECryptoParams>(*m_params);
+    NativeInteger beta = GetBeta();
+    return m_binfhescheme->EvalSignAlt(params, m_BTKey_map, ct, beta, fast, CKKS);
+}
+
+std::vector<LWECiphertext> BinFHEContext::EvalDecompAlt(ConstLWECiphertext ct, bool CKKS) {
+    NativeInteger beta = GetBeta();
+    return m_binfhescheme->EvalDecompAlt(m_params, m_BTKey_map, ct, beta, CKKS);
+}
+
+LWECiphertext BinFHEContext::EvalFloorNew(ConstLWECiphertext ct, uint32_t roundbits) const {
+    //    auto q = m_params->GetLWEParams()->Getq().ConvertToInt();
+    //    if (roundbits != 0) {
+    //        NativeInteger newp = this->GetMaxPlaintextSpace();
+    //        SetQ(q / newp * (1 << roundbits));
+    //    }
+    //    SetQ(q);
+    //    return res;
+    return m_binfhescheme->EvalFloorNew(m_params, m_BTKey, ct, GetBeta(), roundbits);
+}
+
+LWECiphertext BinFHEContext::EvalSignNew(ConstLWECiphertext ct) {
+    auto params        = std::make_shared<BinFHECryptoParams>(*m_params);
+    NativeInteger beta = GetBeta();
+    return m_binfhescheme->EvalSignNew(params, m_BTKey_map, ct, beta);
+}
+
+std::vector<LWECiphertext> BinFHEContext::EvalDecompNew(ConstLWECiphertext ct, bool CKKS) {
+    NativeInteger beta = GetBeta();
+    return m_binfhescheme->EvalDecompNew(m_params, m_BTKey_map, ct, beta, CKKS);
+}
+
+LWECiphertext BinFHEContext::EvalFloorCompress(ConstLWECiphertext ct, uint32_t roundbits) const {
+    return m_binfhescheme->EvalFloorCompress(m_params, m_BTKey, ct, GetBeta(), roundbits);
+}
+
+LWECiphertext BinFHEContext::EvalSignCompress(ConstLWECiphertext ct) {
+    return m_binfhescheme->EvalSignCompress(m_params, m_BTKey_map, ct, GetBeta(), GetBetaPrecise());
+}
+
+std::vector<LWECiphertext> BinFHEContext::EvalDecompCompress(ConstLWECiphertext ct, bool CKKS) {
+    return m_binfhescheme->EvalDecompCompress(m_params, m_BTKey_map, ct, GetBeta(), GetBetaPrecise(), CKKS);
 }
 
 std::vector<NativeInteger> BinFHEContext::GenerateLUTviaFunction(NativeInteger (*f)(NativeInteger m, NativeInteger p),
diff --git a/src/binfhe/lib/lwe-pke.cpp b/src/binfhe/lib/lwe-pke.cpp
index 8524685..191fd13 100644
--- a/src/binfhe/lib/lwe-pke.cpp
+++ b/src/binfhe/lib/lwe-pke.cpp
@@ -120,7 +120,7 @@ void LWEEncryptionScheme::Decrypt(const std::shared_ptr<LWECryptoParams> params,
     // But the method below is a more efficient way of doing the rounding
     // the idea is that Round(4/q x) = q/8 + Floor(4/q x)
     r.ModAddFastEq((mod / (p * 2)), mod);
-    *result = ((NativeInteger(p) * r) / mod).ConvertToInt();
+    *result = static_cast<uint64_t>((uint128_t(p) * r.ConvertToInt()) / mod.ConvertToInt());
 
 #if defined(BINFHE_DEBUG)
     double error =
@@ -222,7 +222,7 @@ LWESwitchingKey LWEEncryptionScheme::KeySwitchGen(const std::shared_ptr<LWECrypt
     for (size_t i = 0; i < N; ++i) {
         std::vector<std::vector<NativeVector>> vector1A(baseKS);
         std::vector<std::vector<NativeInteger>> vector1B(baseKS);
-        for (size_t j = 0; j < baseKS; ++j) {
+        for (size_t j = 1; j < baseKS; ++j) {  // NOTE: skip j = 0 case
             std::vector<NativeVector> vector2A(digitCount);
             std::vector<NativeInteger> vector2B(digitCount);
             for (size_t k = 0; k < digitCount; ++k) {
@@ -268,16 +268,121 @@ LWECiphertext LWEEncryptionScheme::KeySwitch(const std::shared_ptr<LWECryptoPara
     // creates an empty vector
     NativeVector a(n, Q);
     NativeInteger b = ctQN->GetB();
+#ifdef KS_BENCH
+    auto t_start = std::chrono::steady_clock::now();
+#endif
     for (size_t i = 0; i < N; ++i) {
         NativeInteger atmp = ctQN->GetA(i);
         for (size_t j = 0; j < digitCount; ++j, atmp /= baseKS) {
             uint64_t a0 = (atmp % baseKS).ConvertToInt();
-            for (size_t k = 0; k < n; ++k)
-                a[k].ModSubFastEq(K->GetElementsA()[i][a0][j][k], Q);
-            b.ModSubFastEq(K->GetElementsB()[i][a0][j], Q);
+            if (a0 > 0) {  // NOTE: skip a0 = 0 case
+                for (size_t k = 0; k < n; ++k)
+                    a[k].ModSubFastEq(K->GetElementsA()[i][a0][j][k], Q);
+                b.ModSubFastEq(K->GetElementsB()[i][a0][j], Q);
+            }
+        }
+    }
+#ifdef KS_BENCH
+    auto t_end = std::chrono::steady_clock::now();
+    std::cout << "LWE KS takes " << (t_end - t_start).count() << " ns\n";
+#endif
+    return std::make_shared<LWECiphertextImpl>(LWECiphertextImpl(std::move(a), b));
+}
+
+LWESwitchingKeyMult LWEEncryptionScheme::KeySwitchGenMult(const std::shared_ptr<LWECryptoParams> params,
+                                                          ConstLWEPrivateKey sk, ConstLWEPrivateKey skN) const {
+    // Create local copies of main variables
+    uint32_t n        = params->Getn();
+    uint32_t N        = params->GetN();
+    NativeInteger qKS = params->GetqKS();
+    uint32_t baseKS   = params->GetBaseKS();
+    // Number of digits in representing numbers mod qKS
+    uint32_t digitCount = (uint32_t)std::ceil(log(qKS.ConvertToDouble()) / log(static_cast<double>(baseKS)));
+    std::vector<NativeInteger> digitsKS;
+    // Populate digits
+    NativeInteger value = 1;
+    for (size_t i = 0; i < digitCount; ++i) {
+        digitsKS.push_back(value);
+        value *= baseKS;
+    }
+
+    // newSK stores negative values using modulus q
+    // we need to switch to modulus Q
+    NativeVector sv = sk->GetElement();
+    sv.SwitchModulus(qKS);
+
+    NativeVector svN = skN->GetElement();
+    svN.SwitchModulus(qKS);
+
+    DiscreteUniformGeneratorImpl<NativeVector> dug;
+    dug.SetModulus(qKS);
+
+    NativeInteger mu = qKS.ComputeMu();
+
+    std::vector<std::vector<NativeVector>> resultVecA(N);
+    std::vector<std::vector<NativeInteger>> resultVecB(N);
+    // index [i][k] is an LWE encryption of skN[i] * B^k under (q,n)
+#pragma omp parallel for
+    for (size_t i = 0; i < N; ++i) {
+        std::vector<NativeVector> vector1A(baseKS);
+        std::vector<NativeInteger> vector1B(baseKS);
+        for (size_t k = 0; k < digitCount; ++k) {
+            NativeInteger b =
+                (params->GetDggKS().GenerateInteger(qKS)).ModAdd(svN[i].ModMul(digitsKS[k], qKS), qKS);
+            NativeVector a = dug.GenerateVector(n);
+#if NATIVEINT == 32
+            for (size_t i = 0; i < n; ++i) {
+                b.ModAddFastEq(a[i].ModMulFast(sv[i], qKS, mu), qKS);
+            }
+#else
+            for (size_t i = 0; i < n; ++i) {
+                b += a[i].ModMulFast(sv[i], qKS, mu);
+            }
+            b.ModEq(qKS);
+#endif
+            vector1A[k] = std::move(a);
+            vector1B[k] = std::move(b);
         }
+        resultVecA[i] = std::move(vector1A);
+        resultVecB[i] = std::move(vector1B);
     }
 
+    return std::make_shared<LWESwitchingKeyMultImpl>(LWESwitchingKeyMultImpl(resultVecA, resultVecB));
+}
+
+LWECiphertext LWEEncryptionScheme::KeySwitchMult(const std::shared_ptr<LWECryptoParams> params,
+                                                 ConstLWESwitchingKeyMult K, ConstLWECiphertext ctQN) const {
+        uint32_t n          = params->Getn();
+    uint32_t N          = params->GetN();
+    NativeInteger Q     = params->GetqKS();
+    uint32_t baseKS     = params->GetBaseKS();
+    uint32_t digitCount = (uint32_t)std::ceil(log(Q.ConvertToDouble()) / log(static_cast<double>(baseKS)));
+
+    // creates an empty vector
+    NativeVector a(n, Q);
+    NativeInteger b = ctQN->GetB();
+    int64_t Qs = Q.ConvertToInt();
+    int64_t baseKSs = baseKS;
+    NativeInteger mu = Q.ComputeMu();
+    for (size_t i = 0; i < N; ++i) {
+        // signed decomposition
+        int64_t atmp = ctQN->GetA(i).ConvertToInt();
+        if(atmp >= Qs >> 1)
+            atmp -= Qs; 
+        for (size_t j = 0; j < digitCount; ++j, atmp /= baseKS) {
+            int64_t a0s = atmp % baseKSs;
+            if(a0s >= baseKSs >> 1)
+                a0s -= baseKSs;
+            atmp -= a0s;
+            if(a0s < 0)
+                a0s += Qs;
+            if (a0s != 0) {  // NOTE: skip a0s = 0 case
+                for (size_t k = 0; k < n; ++k)
+                    a[k].ModSubFastEq(K->GetElementsA()[i][j][k].ModMulFast(a0s, Q, mu), Q);
+                b.ModSubFastEq(K->GetElementsB()[i][j].ModMulFast(a0s, Q, mu), Q);
+            }
+        }
+    }
     return std::make_shared<LWECiphertextImpl>(LWECiphertextImpl(std::move(a), b));
 }
 
diff --git a/src/core/include/lattice/poly.h b/src/core/include/lattice/poly.h
index 772d871..e78fef8 100644
--- a/src/core/include/lattice/poly.h
+++ b/src/core/include/lattice/poly.h
@@ -54,6 +54,13 @@
 
 namespace lbcrypto {
 
+// ref: https://stackoverflow.com/questions/44012938
+template <class, template <class> class>
+struct is_instance : public std::false_type {};
+
+template <class T, template <class> class U>
+struct is_instance<U<T>, U> : public std::true_type {};
+
 /**
  * @class PolyImpl
  * @file poly.h
@@ -792,6 +799,42 @@ public:
    */
     PolyImpl ShiftRight(unsigned int n) const;
 
+    /**
+   * @brief Shift right by n negacyclicly (multiply by X^n)
+   *
+   * @param n the number of entries to shift right.
+   * @return is the resulting vector from shifting right.
+   */
+    // it seems we cannot move denifinition to poly.cpp...
+    template <typename dummy = void>
+    [[nodiscard]] PolyImpl ShiftRightNegacyclic(
+        unsigned int n, std::enable_if_t<is_instance<VecType, intnat::NativeVectorT>::value, dummy>* = 0) const {
+        if (m_format != Format::COEFFICIENT)
+            OPENFHE_THROW(openfhe_error, "negacyclic rotation is only supported in coefficient format");
+
+        PolyImpl<VecType> tmp = CloneParametersOnly();
+        tmp.SetValues(GetValues().ShiftRightNegacyclic(n), Format::COEFFICIENT);
+        return tmp;
+
+        // auto length = GetLength();
+        // n %= 2 * length;
+        // auto modulus = GetModulus();
+        // if (n >= length) {
+        //     n -= length;
+        //     for (usint i = 0; i < n; i++)
+        //         tmp[i] = at(length - n + i);
+        //     for (usint i = n; i < length; i++)
+        //         tmp[i] = (-at(i - n)).Mod(modulus);
+        // }
+        // else {
+        //     for (usint i = 0; i < n; i++)
+        //         tmp[i] = (-at(length - n + i)).Mod(modulus);
+        //     for (usint i = n; i < length; i++)
+        //         tmp[i] = at(i - n);
+        // }
+        // return tmp;
+    }
+
     /**
    * @brief ostream operator
    * @param os the input preceding output stream
diff --git a/src/core/include/math/hal/intnat/mubintvecnat.h b/src/core/include/math/hal/intnat/mubintvecnat.h
index 5386d6c..f6da65f 100644
--- a/src/core/include/math/hal/intnat/mubintvecnat.h
+++ b/src/core/include/math/hal/intnat/mubintvecnat.h
@@ -324,6 +324,23 @@ public:
    */
     const NativeVectorT& ModEq(const IntegerType& modulus);
 
+    /**
+     * Reduce to inner modulus
+    */
+    const NativeVectorT& ModReduce();
+
+    /**
+     * Non-mod addition
+    */
+    const NativeVectorT& AddEq(const NativeVectorT& b);
+
+    const NativeVectorT& AddEq(const IntegerType& b);
+
+    /**
+     * Non-mod substraction
+    */
+    const NativeVectorT& SubEq(const NativeVectorT& b);
+
     /**
    * Scalar modulus addition.
    *
@@ -560,6 +577,8 @@ public:
    */
     NativeVectorT GetDigitAtIndexForBase(usint index, usint base) const;
 
+    [[nodiscard]] NativeVectorT ShiftRightNegacyclic(usint shift) const;
+
     // STRINGS & STREAMS
 
     /**
diff --git a/src/core/lib/math/hal/intnat/mubintvecnat.cpp b/src/core/lib/math/hal/intnat/mubintvecnat.cpp
index fe17a1a..21a684c 100644
--- a/src/core/lib/math/hal/intnat/mubintvecnat.cpp
+++ b/src/core/lib/math/hal/intnat/mubintvecnat.cpp
@@ -199,13 +199,13 @@ void NativeVectorT<IntegerType>::SetModulus(const IntegerType& value) {
 template <class IntegerType>
 void NativeVectorT<IntegerType>::SwitchModulus(const IntegerType& newModulus) {
     IntegerType oldModulus(this->m_modulus);
-    IntegerType oldModulusByTwo(oldModulus >> 1);
+    IntegerType oldModulusByTwo((oldModulus+1) >> 1); // NOTE: conform with two's complement
     IntegerType diff((oldModulus > newModulus) ? (oldModulus - newModulus) : (newModulus - oldModulus));
 
     if (newModulus > oldModulus) {
         for (usint i = 0; i < this->m_data.size(); i++) {
             IntegerType n = this->m_data[i];
-            if (n > oldModulusByTwo) {
+            if (n >= oldModulusByTwo) { // two's complement
                 this->m_data[i] += diff;
             }
         }
@@ -213,7 +213,7 @@ void NativeVectorT<IntegerType>::SwitchModulus(const IntegerType& newModulus) {
     else {  // newModulus <= oldModulus
         for (usint i = 0; i < this->m_data.size(); i++) {
             IntegerType n        = this->m_data[i];
-            IntegerType sub_diff = (n > oldModulusByTwo) ? diff : 0;
+            IntegerType sub_diff = (n >= oldModulusByTwo) ? diff : 0;
             this->m_data[i]      = n.ModSub(sub_diff, newModulus);
         }
     }
@@ -266,6 +266,46 @@ const NativeVectorT<IntegerType>& NativeVectorT<IntegerType>::ModEq(const Intege
     }
 }
 
+template <class IntegerType>
+const NativeVectorT<IntegerType>& NativeVectorT<IntegerType>::ModReduce() {
+    IntegerType modulus = this->m_modulus;
+    for(usint i = 0; i < this->m_data.size(); i++) {
+        this->m_data[i].ModEq(modulus);
+    }
+    return *this;
+}
+
+template <class IntegerType>
+const NativeVectorT<IntegerType>& NativeVectorT<IntegerType>::AddEq(const NativeVectorT& b) {
+    if ((this->m_data.size() != b.m_data.size()) || this->m_modulus != b.m_modulus) {
+        OPENFHE_THROW(lbcrypto::math_error, "ModAddEq called on NativeVectorT's with different parameters.");
+    }
+    for (usint i = 0; i < this->m_data.size(); i++) {
+        this->m_data[i].AddEq(b.m_data[i]);
+    }
+    return *this;
+}
+
+template <class IntegerType>
+const NativeVectorT<IntegerType>& NativeVectorT<IntegerType>::AddEq(const IntegerType& b) {
+    IntegerType bLocal  = b;
+    for (usint i = 0; i < this->m_data.size(); i++) {
+        this->m_data[i].AddEq(bLocal);
+    }
+    return *this;
+}
+
+template <class IntegerType>
+const NativeVectorT<IntegerType>& NativeVectorT<IntegerType>::SubEq(const NativeVectorT& b) {
+    if ((this->m_data.size() != b.m_data.size()) || this->m_modulus != b.m_modulus) {
+        OPENFHE_THROW(lbcrypto::math_error, "ModAddEq called on NativeVectorT's with different parameters.");
+    }
+    for (usint i = 0, len = this->m_data.size(); i < len; i++) {
+        this->m_data[i].SubEq(b.m_data[i]);
+    }
+    return *this;
+}
+
 template <class IntegerType>
 NativeVectorT<IntegerType> NativeVectorT<IntegerType>::ModAdd(const IntegerType& b) const {
     IntegerType modulus = this->m_modulus;
@@ -592,6 +632,28 @@ NativeVectorT<IntegerType> NativeVectorT<IntegerType>::GetDigitAtIndexForBase(us
     return ans;
 }
 
+template <class IntegerType>
+[[nodiscard]] NativeVectorT<IntegerType> NativeVectorT<IntegerType>::ShiftRightNegacyclic(usint n) const {
+    auto length = m_data.size();
+    NativeVectorT ans(length, m_modulus);
+
+    n %= 2 * length;
+    if (n >= length) {
+        n -= length;
+        for (usint i = 0; i < n; i++)
+            ans.m_data[i] = m_data[length - n + i];
+        for (usint i = n; i < length; i++)
+            ans.m_data[i] = (m_modulus - m_data[i - n]).Mod(m_modulus);
+    }
+    else {
+        for (usint i = 0; i < n; i++)
+            ans.m_data[i] = (m_modulus - m_data[length - n + i]).Mod(m_modulus);
+        for (usint i = n; i < length; i++)
+            ans.m_data[i] = m_data[i - n];
+    }
+    return ans;
+}
+
 template class NativeVectorT<NativeInteger>;
 
 }  // namespace intnat
